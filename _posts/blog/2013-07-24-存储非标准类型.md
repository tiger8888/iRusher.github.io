---
layout: post
title: CoreData - 存储非标准类型 
categories:blog 
tags: ios coredata document 
---

#CoreData - 存储非标准类型
---
by Rusher@2013-07-24

非标准类型表示除CoreData默认支持的类型(int,double,NSString等等)以外的其他类型，比如一个矩形的颜色，还有Frame等，这些量CoreData默认不支持，需要做一些额外的工作使CoreData支持。方法有两种，一是使用NSValueFromater做值转换，把值的一种表现形式转化为另一种表现形式；第二种是在NSManagedObject中使用临时变量存储不支持的类型的变量。两种解决方法的原理其实是类似的，都是把**属性的表现形式转化成CoreData支持的类型**，然后做持久化。

## 值转换(NSValueTransformer)

值转换的原理是将属性通过`NSValueTransformer`的一个实例，将值转化为**NSData**,然后持久化到数据库中。如果使用SQLite，自定义的类型对应数据库中的`Blob`类型.

下面的例子中，我们需要持久化一个CGSize。(在这里需要先用NSValue包装一下，而且这个例子只是演示怎么使用，还有更好的解决方法)

1.在Model编辑器中设置添加的属性的类型为`Transfomable`,然后在DataModel inspector中设置转化类的类名

2.继承`NSValueTransformer`类

	//RSSizeTransformer.h
	
	@interface RSSizeTransformer : NSValueTransformer
	@end
	
	//RSSizeTransformer.m
	
	#import "RSSizeTransformer.h"
	
	@implementation RSSizeTransformer
	
	+ (Class)transformedValueClass {
	    return [NSData class];
	}
	
	+ (BOOL)allowsReverseTransformation {
	    return YES;
	}
	
	- (id)transformedValue:(id)value
	{
	    NSAssert([value class]!=[NSValue class], @"value must be NSValue");
	    
	    NSValue *v = (NSValue*)value;
	    CGSize size = v.CGSizeValue;
	    
	    NSString *str = NSStringFromCGSize(size);
	    return [str dataUsingEncoding:NSUTF8StringEncoding];
	}
	
	- (id)reverseTransformedValue:(id)value
	{
	    NSAssert([value class]!=[NSData class], @"value must be NSValue");
	    NSString *str = [[NSString alloc] initWithData:value
	                                          encoding:NSUTF8StringEncoding];
	    CGSize size = CGSizeFromString(str);
	    return [NSValue valueWithCGSize:size];
	}
	
	@end


[NSHipster](http://nshipster.com/nsvaluetransformer/)有一篇关于`NSValueTransformer`的文章。当然`NSValueTransformer`也不仅限于在CoreData中使用。Matt(AFNetworking的作者)还提供了一个快捷的`TransformerKit`,通过元变成快速的注册一个`NSValueTransformer`。

上面的代码还可以这样实现：

    [NSValueTransformer registerValueTransformerWithName:sizeTransformerName
                                   transformedValueClass:[NSString class]
                      returningTransformedValueWithBlock:^id(id value) {
                          
                          NSValue *v = (NSValue*)value;
                          CGSize size = v.CGSizeValue;
                          
                          NSString *str = NSStringFromCGSize(size);
                          return str;
                      }
                  allowingReverseTransformationWithBlock:^id(id value) {
                      
                      NSString *str = [[NSString alloc] initWithData:value encoding:NSUTF8StringEncoding];
                      CGSize size = CGSizeFromString(str);
                      return [NSValue valueWithCGSize:size];
                  }];

通过[NSValueTransformer+TransformerKit](https://github.com/mattt/TransformerKit/blob/master/TransformerKit/NSValueTransformer%2BTransformerKit.m)的源码看一下**元编程**的威力吧。

>    注意：CoreData中，只能使用`NSValueTransformer`将值转化为`NSData`

## 临时变量(Transient)

对临时变量的存取有几种策略。对于获取临时变量来说，有两种情况，一种是"懒加载(On-demand)"，在需要的时候才去计算临时变量的值；另一种是“预计算(Pre-calculated)”，当拿到原始的值后，就立即计算临时变量的值(通常在awakeFromFetch中计算)。如果值比较大，使用“懒加载”更适合一些。对于真正持久化的值来说，有两种方式，一种是“立即更新(Immediate-update)”，每次值改变时就持久化库中，另外一种是“延迟更新(Delayed-update)”，只有当存储ManagedObject的时候才一并更新到持久化库中。

### On-demand

	- (NSColor *)color {
	 
	    [self willAccessValueForKey:@"color"];
	    NSColor *color = [self primitiveColor];
	    [self didAccessValueForKey:@"color"];
	    if (color == nil) {
	        NSData *colorData = [self colorData];
	        if (colorData != nil) {
	            color = [NSKeyedUnarchiver unarchiveObjectWithData:colorData];
	            [self setPrimitiveColor:color];
	        }
	    }
	    return color;
	}

### Pre-calculate

从持久化库中得到数据后，ManagedObject的`awakeFromFetch`方法被调用：

	- (void)awakeFromFetch {
	 
	    [super awakeFromFetch];
	    NSData *colorData = [self colorData];
	    if (colorData != nil) {
	        NSColor *color = [NSKeyedUnarchiver unarchiveObjectWithData:colorData];
	        [self setPrimitiveColor:color];
	    }
	}

属性的访问器中：

	- (NSColor *)color {
	 
	    [self willAccessValueForKey:@"color"];
	    NSColor *color = [self primitiveColor];
	    [self didAccessValueForKey:@"color"];
	    return color;
	}

### Immediate-update

	- (void)setColor:(NSColor *)aColor {
	 
	    [self willChangeValueForKey:@"color"];
	    [self setPrimitiveValue:aColor forKey:@"color"];
	    [self didChangeValueForKey:@"color"];
	    [self setValue:[NSKeyedArchiver archivedDataWithRootObject:aColor]
	                forKey:@"colorData"];
	}
	

### Delayed-update

	- (void)setColor:(NSColor *)aColor {
	 
	    [self willChangeValueForKey:@"color"];
	    [self setPrimitiveValue:aColor forKey:@"color"];
	    [self didChangeValueForKey:@"color"];
	}
	 
	- (void)willSave {
	 
	    NSColor *color = [self primitiveValueForKey:@"color"];
	    if (color != nil) {
	        [self setPrimitiveValue:[NSKeyedArchiver archivedDataWithRootObject:color]
	                forKey:@"colorData"];
	    }
	    else {
	        [self setPrimitiveValue:nil forKey:@"colorData"];
	    }
	    [super willSave];
	}
