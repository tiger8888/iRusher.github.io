<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>iRusher.com</title>
   <link href="http://iRusher.com/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://iRusher.com" rel="alternate" type="text/html" />
   <updated>2013-07-25T16:30:21+08:00</updated>
   <id>http://iRusher.com</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>CoreData - 存储非标准类型</title>
     <link href="http://beiyuu.com/%E5%AD%98%E5%82%A8%E9%9D%9E%E6%A0%87%E5%87%86%E7%B1%BB%E5%9E%8B"/>
     <updated>2013-07-24T00:00:00+08:00</updated>
     <id>http://beiyuu.com/存储非标准类型</id>
     <content type="html">&lt;p&gt;非标准类型表示除CoreData默认支持的类型(int,double,NSString等等)以外的其他类型，比如一个矩形的颜色，还有Frame等，这些量CoreData默认不支持，需要做一些额外的工作使CoreData支持。方法有两种，一是使用NSValueFromater做值转换，把值的一种表现形式转化为另一种表现形式；第二种是在NSManagedObject中使用临时变量存储不支持的类型的变量。两种解决方法的原理其实是类似的，都是把&lt;strong&gt;属性的表现形式转化成CoreData支持的类型&lt;/strong&gt;，然后做持久化。&lt;/p&gt;

&lt;h2&gt;值转换(NSValueTransformer)&lt;/h2&gt;

&lt;p&gt;值转换的原理是将属性通过&lt;code&gt;NSValueTransformer&lt;/code&gt;的一个实例，将值转化为&lt;strong&gt;NSData&lt;/strong&gt;,然后持久化到数据库中。如果使用SQLite，自定义的类型对应数据库中的&lt;code&gt;Blob&lt;/code&gt;类型.&lt;/p&gt;

&lt;p&gt;下面的例子中，我们需要持久化一个CGSize。(在这里需要先用NSValue包装一下，而且这个例子只是演示怎么使用，还有更好的解决方法)&lt;/p&gt;

&lt;p&gt;1.在Model编辑器中设置添加的属性的类型为&lt;code&gt;Transfomable&lt;/code&gt;,然后在DataModel inspector中设置转化类的类名&lt;/p&gt;

&lt;p&gt;2.继承&lt;code&gt;NSValueTransformer&lt;/code&gt;类&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//RSSizeTransformer.h

@interface RSSizeTransformer : NSValueTransformer
@end

//RSSizeTransformer.m

#import &quot;RSSizeTransformer.h&quot;

@implementation RSSizeTransformer

+ (Class)transformedValueClass {
    return [NSData class];
}

+ (BOOL)allowsReverseTransformation {
    return YES;
}

- (id)transformedValue:(id)value
{
    NSAssert([value class]!=[NSValue class], @&quot;value must be NSValue&quot;);

    NSValue *v = (NSValue*)value;
    CGSize size = v.CGSizeValue;

    NSString *str = NSStringFromCGSize(size);
    return [str dataUsingEncoding:NSUTF8StringEncoding];
}

- (id)reverseTransformedValue:(id)value
{
    NSAssert([value class]!=[NSData class], @&quot;value must be NSValue&quot;);
    NSString *str = [[NSString alloc] initWithData:value
                                          encoding:NSUTF8StringEncoding];
    CGSize size = CGSizeFromString(str);
    return [NSValue valueWithCGSize:size];
}

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;http://nshipster.com/nsvaluetransformer/&quot;&gt;NSHipster&lt;/a&gt;有一篇关于&lt;code&gt;NSValueTransformer&lt;/code&gt;的文章。当然&lt;code&gt;NSValueTransformer&lt;/code&gt;也不仅限于在CoreData中使用。Matt(AFNetworking的作者)还提供了一个快捷的&lt;code&gt;TransformerKit&lt;/code&gt;,通过元变成快速的注册一个&lt;code&gt;NSValueTransformer&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;上面的代码还可以这样实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[NSValueTransformer registerValueTransformerWithName:sizeTransformerName
                               transformedValueClass:[NSData class]
                  returningTransformedValueWithBlock:^id(id value) {

                      NSValue *v = (NSValue*)value;
                      CGSize size = v.CGSizeValue;

                      NSString *str = NSStringFromCGSize(size);
                      return [str dataUsingEncoding:NSUTF8StringEncoding];
                  }
              allowingReverseTransformationWithBlock:^id(id value) {

                  NSString *str = [[NSString alloc] initWithData:value
                                                        encoding:NSUTF8StringEncoding];
                  CGSize size = CGSizeFromString(str);
                  return [NSValue valueWithCGSize:size];
              }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过&lt;a href=&quot;https://github.com/mattt/TransformerKit/blob/master/TransformerKit/NSValueTransformer%2BTransformerKit.m&quot;&gt;NSValueTransformer+TransformerKit&lt;/a&gt;的源码看一下&lt;strong&gt;元编程&lt;/strong&gt;的威力吧。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;   注意：CoreData中，只能使用&lt;code&gt;NSValueTransformer&lt;/code&gt;将值转化为&lt;code&gt;NSData&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2&gt;临时变量(Transient)&lt;/h2&gt;

&lt;p&gt;对临时变量的存取有几种策略。对于获取临时变量来说，有两种情况，一种是&quot;懒加载(On-demand)&quot;，在需要的时候才去计算临时变量的值；另一种是“预计算(Pre-calculated)”，当拿到原始的值后，就立即计算临时变量的值(通常在awakeFromFetch中计算)。如果值比较大，使用“懒加载”更适合一些。对于真正持久化的值来说，有两种方式，一种是“立即更新(Immediate-update)”，每次值改变时就持久化库中，另外一种是“延迟更新(Delayed-update)”，只有当存储ManagedObject的时候才一并更新到持久化库中。&lt;/p&gt;

&lt;h3&gt;On-demand&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;- (NSColor *)color {

    [self willAccessValueForKey:@&quot;color&quot;];
    NSColor *color = [self primitiveColor];
    [self didAccessValueForKey:@&quot;color&quot;];
    if (color == nil) {
        NSData *colorData = [self colorData];
        if (colorData != nil) {
            color = [NSKeyedUnarchiver unarchiveObjectWithData:colorData];
            [self setPrimitiveColor:color];
        }
    }
    return color;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Pre-calculate&lt;/h3&gt;

&lt;p&gt;从持久化库中得到数据后，ManagedObject的&lt;code&gt;awakeFromFetch&lt;/code&gt;方法被调用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)awakeFromFetch {

    [super awakeFromFetch];
    NSData *colorData = [self colorData];
    if (colorData != nil) {
        NSColor *color = [NSKeyedUnarchiver unarchiveObjectWithData:colorData];
        [self setPrimitiveColor:color];
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;属性的访问器中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (NSColor *)color {

    [self willAccessValueForKey:@&quot;color&quot;];
    NSColor *color = [self primitiveColor];
    [self didAccessValueForKey:@&quot;color&quot;];
    return color;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Immediate-update&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;- (void)setColor:(NSColor *)aColor {

    [self willChangeValueForKey:@&quot;color&quot;];
    [self setPrimitiveValue:aColor forKey:@&quot;color&quot;];
    [self didChangeValueForKey:@&quot;color&quot;];
    [self setValue:[NSKeyedArchiver archivedDataWithRootObject:aColor]
                forKey:@&quot;colorData&quot;];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Delayed-update&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;- (void)setColor:(NSColor *)aColor {

    [self willChangeValueForKey:@&quot;color&quot;];
    [self setPrimitiveValue:aColor forKey:@&quot;color&quot;];
    [self didChangeValueForKey:@&quot;color&quot;];
}

- (void)willSave {

    NSColor *color = [self primitiveValueForKey:@&quot;color&quot;];
    if (color != nil) {
        [self setPrimitiveValue:[NSKeyedArchiver archivedDataWithRootObject:color]
                forKey:@&quot;colorData&quot;];
    }
    else {
        [self setPrimitiveValue:nil forKey:@&quot;colorData&quot;];
    }
    [super willSave];
}
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
 
</feed>
