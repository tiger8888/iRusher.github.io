<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 
   <title>iRusher.com</title>
   <link href="http://iRusher.com/atom.xml" rel="self" type="application/atom+xml"/>
   <link href="http://iRusher.com" rel="alternate" type="text/html" />
   <updated>2013-08-14T18:04:25+08:00</updated>
   <id>http://iRusher.com</id>
   <author>
     <name></name>
     <email></email>
   </author>

   
   <entry>
     <title>Objective-C runtime学习笔记</title>
     <link href="http://beiyuu.com/objective-c-runtime%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"/>
     <updated>2013-08-14T00:00:00+08:00</updated>
     <id>http://beiyuu.com/objective-c-runtime学习笔记</id>
     <content type="html">&lt;p&gt;runtime相关的内容最近经常看到，看大牛们用到这些特性就像这样:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://i1.hoopchina.com.cn/user/376/3409376/1277105284c636c.gif&quot; alt=&quot;nb.gif&quot; /&gt;&lt;/p&gt;

&lt;p&gt;尤其是在一些工具类中，使用runtime的特性，通常能达到事半功倍的效果。&lt;/p&gt;

&lt;h2&gt;Message,Method,Selector,Message Signature,Implementation的区别&lt;/h2&gt;

&lt;p&gt;一开始的时候可能会把这些概念都看做一个东西: 传统意义上的一个函数调用。但是，要使用runtime的特性时，这些概念就有必要分清楚。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Selector(选择器)&lt;/strong&gt; : 一个方法的名字。就像&lt;code&gt;alloc&lt;/code&gt;,&lt;code&gt;init&lt;/code&gt;,&lt;code&gt;dictionaryWithObjectsAndKeys:&lt;/code&gt;，其中的冒号也是Selector的一部分，用来标识方法是否需要参数。Selector有一个类型&lt;code&gt;SEL&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;SEL aSelector = @selector(doSomething:);
// or
SEL aSelector = NSSelectorFromString(@&quot;doSomething&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Message(消息)&lt;/strong&gt; : Selector和传入方法的参数构成一个Message。如果看到&lt;code&gt;[dictionary setObject:obj forKey:key]&lt;/code&gt;,那么Message就是一个 &lt;strong&gt;Selector&lt;/strong&gt;(&lt;code&gt;setObject:forKey:&lt;/code&gt;)加 &lt;strong&gt;参数&lt;/strong&gt;(&lt;code&gt;obj&lt;/code&gt;和&lt;code&gt;key&lt;/code&gt;) 。Message可以被封装到&lt;code&gt;NSInvocation&lt;/code&gt;对象中。消息被发送到接收方，通常接收方是一个对象。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Method(方法)&lt;/strong&gt; : Selecotr和“实现”（还有附带的元数据）构成一个Method。“实现”是一个函数指针(&lt;code&gt;IMP&lt;/code&gt;),指向一段代码块。一个Method在运行时表示为&lt;code&gt;Method&lt;/code&gt;结构体。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Method Signature(方法签名)&lt;/strong&gt; : 方法签名记录一个方法的返回值的类型和传入参数的类型。在运行时由一个&lt;code&gt;NSMethodSignature&lt;/code&gt;或一个&lt;code&gt;char *&lt;/code&gt;字符串指针表示。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Implementation(方法实现)&lt;/strong&gt; : “实现”在运行时中表示为&lt;code&gt;IMP&lt;/code&gt;类型。事实上，这只是一个函数指针。iOS 4.3后包含了将一个&lt;code&gt;block&lt;/code&gt;转化为&lt;code&gt;IMP&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;IMP imp_implementationWithBlock(id block);
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;Message动态绑定&lt;/h2&gt;

&lt;h3&gt;objc_message&lt;/h3&gt;

&lt;p&gt;在Objective-C中，Message只有在运行的时候才和方法实现绑定在一起，这就是所谓的动态绑定。编译器将一个表达式&lt;code&gt;[receiver message]&lt;/code&gt;转换成&lt;code&gt;objc_msgSend(receiver, selector)&lt;/code&gt;，如果消息中带有参数，也一并传递给&lt;code&gt;objc_msgSend&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;objc_msgSend(receiver, selector, arg1, arg2, ...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;objc_msgSend&lt;/code&gt;完成整个动态绑定的过程：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;首先，它会寻找&lt;code&gt;selector&lt;/code&gt;指向的方法实现。由于相同的方法可能在不同的类中实现，具体指向的方法实现取决于&lt;code&gt;receiver&lt;/code&gt;;&lt;/li&gt;
&lt;li&gt;接下来调用方法实现，传入的所有参数都将传递给方法实现，接受对象自己也被传入方法实现(即&lt;code&gt;self&lt;/code&gt;)；&lt;/li&gt;
&lt;li&gt;最后，将方法实现的返回值作为自己的返回值返回。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;Message传递的关键点在编译器为Class和Object构建的结构中。每个类结构都包含以下两个元素：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;一个指向超类的指针；&lt;/li&gt;
&lt;li&gt;一个类分发表(dispath table)。表中的记录由 &lt;strong&gt;方法的Selector&lt;/strong&gt; 和与其关联的具体的类的 &lt;strong&gt;方法实现的地址&lt;/strong&gt; 构成。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;isa&lt;/h3&gt;

&lt;p&gt;当一个对象被创建后，它所占用的内存被分配，实例变量被初始化，紧接着，对象中的一个指针指向了对象的类结构，这个指针叫&lt;code&gt;isa&lt;/code&gt;，可以使对象访问到它对应的类以及父类。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Art/messaging1.gif&quot; alt=&quot;isa&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当一个Message被发送到对象后，&lt;code&gt;objc_message&lt;/code&gt;顺着对象的&lt;code&gt;isa&lt;/code&gt;指针在其dispatch_table中查找Selector。如果没有找到，继续在超类的dispath_table中查找，如果一直未找到，则最终会到达&lt;code&gt;NSObject&lt;/code&gt;类中；如果找到，就调用dispatch_table中Selector对应的方法实现，Messsage中传入的参数也一并交给方法实现。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;  选择使用哪个方法实现，是在运行过程中决定的，这就是消息的动态绑定。&lt;/p&gt;&lt;/blockquote&gt;

&lt;p&gt;为了加速动态查询的过程，运行时系统将Selector和它使用过的方法实现缓存起来。每个类持有各自的缓存，被缓存的方法实现可以使自己类中的，也可以是从超类中继承的。在搜索dispatch_table之前，先查询消息接受对象的类的缓存，如果找到，就直接使用缓存中的方法实现。&lt;/p&gt;

&lt;h2&gt;@dynamic&lt;/h2&gt;

&lt;h2&gt;Message分发&lt;/h2&gt;
</content>
   </entry>
   
   <entry>
     <title>Gitlab配置ssh连接</title>
     <link href="http://beiyuu.com/gitlab%E9%85%8D%E7%BD%AEssh%E8%BF%9E%E6%8E%A5"/>
     <updated>2013-08-14T00:00:00+08:00</updated>
     <id>http://beiyuu.com/gitlab配置ssh连接</id>
     <content type="html">&lt;h2&gt;ssh公钥登录&lt;/h2&gt;

&lt;p&gt;一般在管理远程主机时，都用ssh登录，&lt;code&gt;ssh user@host&lt;/code&gt;，但是这样每次会使用密码。 使用&lt;code&gt;ssh-keygen&lt;/code&gt;生成的密钥对，然后将公钥添加的目标主机的&lt;code&gt;~/.ssh/authorized_keys&lt;/code&gt;文件中，当前主机就成为可信任的主机，下次使用ssh登录时，就不用输入密码了。&lt;/p&gt;

&lt;p&gt;Gitlab，Github都支持这种方式的连接，具体操作步骤如下：&lt;/p&gt;

&lt;h4&gt;第一步:生成密钥对&lt;/h4&gt;

&lt;p&gt;使用&lt;code&gt;ssh-keygen&lt;/code&gt;生成密钥对:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh-keygen -t rsa -C &quot;你的邮箱&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就在主目录下的&lt;code&gt;.ssh&lt;/code&gt;目录中生成了两个文件&lt;code&gt;id_rsa&lt;/code&gt;和&lt;code&gt;id_rsa.pub&lt;/code&gt;。&lt;code&gt;id_rsa&lt;/code&gt;中保存的是私钥，&lt;code&gt;id_rsa.pub&lt;/code&gt;中保存的是公钥。&lt;/p&gt;

&lt;h4&gt;第二步:添加公钥&lt;/h4&gt;

&lt;p&gt;拷贝公钥到剪切板:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pbcopy &amp;lt; id_rsa.pub
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 个人资料-&gt;SSH Keys-&gt;Add new 页面中粘贴公钥，就添加完成了。&lt;/p&gt;

&lt;h4&gt;第三步:测试&lt;/h4&gt;

&lt;p&gt;ssh加&lt;code&gt;-T&lt;/code&gt;选项测试目标服务是否可用:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh -T git@&quot;你的gitlab服务器地址&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一次连接时，会询问是否信任主机，确认后输入yes。如果看到&lt;code&gt;Welcome to GitLab, Rusher!&lt;/code&gt;就算配置成功了，接下来就可以通过ssh来提交代码了。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;  &lt;strong&gt;Windows&lt;/strong&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt; 下载 &lt;a href=&quot;https://code.google.com/p/msysgit/downloads/detail?name=Git-1.8.3-preview20130601.exe&amp;amp;can=2&amp;amp;q=full+installer+official+git&quot;&gt;Git-Bash&lt;/a&gt;&lt;/li&gt;
&lt;li&gt; 生成密钥对&lt;code&gt;ssh-keygen -t rsa -C &quot;你的邮箱&quot;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt; 生成之后用 &lt;code&gt;notepad c:/User/Administrator/.ssh/id_rsa.pub&lt;/code&gt; 打开文件，然后将公钥添加的Gitlab中.&lt;/li&gt;
&lt;li&gt; 测试 &lt;code&gt;ssh -T git@&quot;你的gitlab服务器地址&quot;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2&gt;Gitlab服务端配置&lt;/h2&gt;

&lt;p&gt;(只使用客户端可忽略这节内容)&lt;/p&gt;

&lt;p&gt;在客户端提交时发现以下错误：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/usr/local/lib/ruby/1.9.1/net/http.rb:762:in `initialize': getaddrinfo: Name or service not known (SocketError)
from /usr/local/lib/ruby/1.9.1/net/http.rb:762:in `open'
from /usr/local/lib/ruby/1.9.1/net/http.rb:762:in `block in connect'
from /usr/local/lib/ruby/1.9.1/timeout.rb:54:in `timeout'
from /usr/local/lib/ruby/1.9.1/timeout.rb:99:in `timeout'
from /usr/local/lib/ruby/1.9.1/net/http.rb:762:in `connect'
from /usr/local/lib/ruby/1.9.1/net/http.rb:755:in `do_start'
from /usr/local/lib/ruby/1.9.1/net/http.rb:744:in `start'
from /home/git/gitlab-shell/lib/gitlab_net.rb:64:in `get'
from /home/git/gitlab-shell/lib/gitlab_net.rb:30:in `check'
from ./check:11:in `&amp;lt;main&amp;gt;'
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在Github的issue里找到说先运行一下&lt;code&gt;/home/git/gitlab-shell/bin/check&lt;/code&gt; 。先做检测，发现和上面一样的错误。看错误是找不到域名，所以在&lt;code&gt;/etc/hosts&lt;/code&gt;中需要配置一个地址的映射。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;127.0.0.1  YOUR_DOMIN # YOUR_DOMIN是在/home/git/gitlab-shell/config.yml中配置的gitlab_url
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;扩展：ssh多用户切换&lt;/h2&gt;

&lt;p&gt;在配置Gitlab的时候一开始是用管理员账户做测试的，后来建了我自己的账号做开发。这样我的本地就有两个Gitlab账号，如果直接用ssh来提交代码有问题，因为ssh默认使用一开始生成id_rsa那个密钥对，但不同的账号又不能对应到同一个公钥上。如果多个账户一起用，还需要做些配置。&lt;/p&gt;

&lt;p&gt;假如有两个账号：root和rusher。&lt;/p&gt;

&lt;h4&gt;第一步:为两个账户分别生成密钥对&lt;/h4&gt;

&lt;p&gt;提示在哪里存储密钥文件的时候，对不同的账号填不同的路径，root放在&lt;code&gt;/Users/you/.ssh/id_rsa_gitlab_root&lt;/code&gt;下，rusher的放在&lt;code&gt;/Users/you/.ssh/id_rsa_gitlab_rusher&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh-keygen -t rsa -C rusher@you.com

Generating public/private rsa key pair.
Enter file in which to save the key (/Users/you/.ssh/id_rsa): /Users/you/.ssh/id_rsa_gitlab_rusher
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /Users/you/.ssh/id_rsa_gitlab_rusher.
Your public key has been saved in /Users/you/.ssh/id_rsa_gitlab_rusher.pub.


ssh-keygen -t rsa -C root@you.com

Generating public/private rsa key pair.
Enter file in which to save the key (/Users/you/.ssh/id_rsa): /Users/you/.ssh/id_rsa_gitlab_root
Enter passphrase (empty for no passphrase): 
Enter same passphrase again: 
Your identification has been saved in /Users/you/.ssh/id_rsa_gitlab_root.
Your public key has been saved in /Users/you/.ssh/id_rsa_gitlab_root.pub.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;还是需要将两个账号的公钥分别添加的各自账号的SSH Keys中(rusher: id_rsa_gitlab_rusher.pub和root: id_rsa_gitlab_root.pub) 。&lt;/p&gt;

&lt;h4&gt;第二步:添加ssh配置文件&lt;/h4&gt;

&lt;p&gt;在.ssh目录中添加&lt;code&gt;config&lt;/code&gt;文件，此文件的为不同的账户添加别名(root: root_gitlab 和 rusher: rusher_gitlab)，连接还是同一个服务器，但是使用不同的密钥文件，所以才能将两个账号分开。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# for root 
Host root_gitlab
  HostName git.you.com
  User git
  IdentityFile /Users/you/.ssh/id_rsa_gitlab

# for rusher
Host rusher_gitlab
  HostName git.you.com
  User git
  IdentityFile /Users/you/.ssh/id_rsa_gitlab_rusher
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下来这样使用别名测试，可以查看是否对应到了正确的账号上：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ssh -T git@root_gitlab 

ssh -T git@rusher_gitlab
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;第三步:在git项目中使用别名&lt;/h4&gt;

&lt;p&gt;正常的项目，我们clone下来之后，origin对应的URL假设为: &lt;code&gt;git@git.:Rusher/helloworld&lt;/code&gt;，现在需要做个改动，将&lt;code&gt;git.&lt;/code&gt;要换成&lt;code&gt;rusher_gitlab&lt;/code&gt;,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git remote set-url origin git@rusher_gitlab:Rusher/helloworld
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是root用户的项目:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git remote set-url origin git@root_gitlab:root/helloworld
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以上配置ssh的方法同样适用于Github,Bitbucket等网站。&lt;/p&gt;

&lt;h2&gt;参考文档&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://help.github.com/articles/generating-ssh-keys&quot;&gt;Github Help&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>Objective-C实现多重代理</title>
     <link href="http://beiyuu.com/objective-c%E5%AE%9E%E7%8E%B0%E5%A4%9A%E9%87%8D%E4%BB%A3%E7%90%86"/>
     <updated>2013-08-07T00:00:00+08:00</updated>
     <id>http://beiyuu.com/objective-c实现多重代理</id>
     <content type="html">&lt;p&gt;在OC中，一般实现代理的模式如下(用NSURLConnection和AFNetworking的代码做示例)：&lt;/p&gt;

&lt;p&gt;首先定义&lt;code&gt;NSURLConnectionDataDelegate&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@protocol NSURLConnectionDataDelegate &amp;lt;NSURLConnectionDelegate&amp;gt;
@optional

…
- (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data;
…
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然后在初始化&lt;code&gt;NSURLConnection&lt;/code&gt;传入一个代理对象；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (id)initWithRequest:(NSURLRequest *)request delegate:(id)delegate;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这个代理对象实现协议中的方法:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;@interface AFURLConnectionOperation : NSOperation &amp;lt;NSURLConnectionDelegate,
#if (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) &amp;amp;&amp;amp; __IPHONE_OS_VERSION_MIN_REQUIRED &amp;gt;= 50000) || \
    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) &amp;amp;&amp;amp; __MAC_OS_X_VERSION_MIN_REQUIRED &amp;gt;= 1080)
NSURLConnectionDataDelegate, 
#endif
NSCoding, NSCopying&amp;gt;

…

- (void)connection:(NSURLConnection __unused *)connection
    didReceiveData:(NSData *)data
{
    NSUInteger length = [data length];
    if ([self.outputStream hasSpaceAvailable]) {
        const uint8_t *dataBuffer = (uint8_t *) [data bytes];
        [self.outputStream write:&amp;amp;dataBuffer[0] maxLength:length];
    }

    dispatch_async(dispatch_get_main_queue(), ^{
        self.totalBytesRead += length;

        if (self.downloadProgress) {
            self.downloadProgress(length, self.totalBytesRead, self.response.expectedContentLength);
        }
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在&lt;code&gt;NSURLConnection&lt;/code&gt;中某个合适的时机，代理方法将被调用。&lt;/p&gt;

&lt;p&gt;这是iOS开发中最常用的一种模式。但是这样做有个小问题，不能将多个不同的对象设置为一个对象代理类。这种应用场景还是很常见的，例如，在聊天页面设置一个收到消息的代理，实时的更新聊天界面，在历史记录页面也是需要设置代理，更新历史记录，但是聊天页面和历史记录肯定是不同的类。在XMPPFramework中，实现了一个工具类&lt;code&gt;GCDMulticastDelegate&lt;/code&gt;,可以将消息分发到多个代理类。&lt;/p&gt;

&lt;h3&gt;GCDMulticastDelegate&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;                                            +--------------------------------------------------+
                                            |Module                                            |
                                            |                                                  |
                                            |                              Call Delegate       |
                                            |                                 |                |
                                            | +-------------------------------v-------------+  |
                                            | |GCDMulticastDelegate                         |  |
                                            | |                               +             |  |
                                            | |                               |             |  |
                                            | | +--------------------------+  |Enumerate    |  |
        +-----------------------+           | | | GCDMulticastDelegateNode |  |             |  |
        |         Object        |  add      | | |--------------------------|  |             |  |
        |-----------------------|&amp;lt;---------------&amp;gt;delegate                 &amp;lt;--+             |  |
        | moduleDelegateMethod  |  call     | | | delegateQueue            |  |             |  |
        +-----------------------+           | | +--------------------------+  |             |  |
                                            | |                               |             |  |
                                            | | +--------------------------+  |             |  |
                                            | | | GCDMulticastDelegateNode |  |             |  |
        +-----------------------+  add      | | |--------------------------|  |             |  |
        |         Object        |&amp;lt;---------------&amp;gt;delegate                 &amp;lt;--+             |  |
        |-----------------------|  call     | | | delegateQueue            |  |             |  |
        | moduleDelegateMethod  |           | | +--------------------------+  |             |  |
        +-----------------------+           | |                               |             |  |
                      ...                   | |             ...               v             |  |
                                            | |                                             |  |
                                            | +---------------------------------------------+  |
                                            |                                                  |
                                            +--------------------------------------------------+
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;模块中有一个类型为&lt;code&gt;GCDMulticastDelegate&lt;/code&gt;的成员变量。 &lt;code&gt;GCDMulticastDelegate&lt;/code&gt;包含一个数组，数组中的每个节点包含实现(其实也可以没有实现)了代理协议中方法的对象的弱引用，这个节点是通过Module暴露出来的方法添加到&lt;code&gt;GCDMulticastDelegate&lt;/code&gt;的。当Module处理过程中，发生了某个事件，调用了代理的方法，&lt;code&gt;GCDMulticastDelegate&lt;/code&gt;就遍历节点数组，一次在节点引用的队列上调用代理方法。&lt;/p&gt;

&lt;p&gt;上面的Module是XMPPFramework中出现的。我把&lt;code&gt;GCDMulticastDelegate&lt;/code&gt;抽取出来，可以为我们所用,代码在&lt;a href=&quot;https://github.com/iRusher/GCDMulticastDelegate&quot;&gt;这里&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;在使用这个多重代理的时候，发现执行代理方法的类不需要实现代理协议，&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>KissXML的XPath选取问题</title>
     <link href="http://beiyuu.com/kissxml%E7%9A%84xpath%E9%80%89%E5%8F%96%E9%97%AE%E9%A2%98"/>
     <updated>2013-08-01T00:00:00+08:00</updated>
     <id>http://beiyuu.com/kissxml的xpath选取问题</id>
     <content type="html">&lt;p&gt;XMPPFramework用的XML解析库还是大神自己写的&lt;a href=&quot;https://github.com/robbiehanson/KissXML&quot;&gt;KissXML&lt;/a&gt;，有些人生下来就是让人仰望的，哎。&lt;/p&gt;

&lt;p&gt;进入主题,如下一段XML:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;params xmlns=&quot;namespace&quot;&amp;gt;
    &amp;lt;param name=&quot;text&quot;&amp;gt;text in element&amp;lt;/param&amp;gt;
    &amp;lt;param name=&quot;voice&quot;&amp;gt;voice in element&amp;lt;/param&amp;gt;
&amp;lt;/params&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;需要得到各个&lt;code&gt;&amp;lt;param/&amp;gt;&lt;/code&gt;子元素中的键值对应关系&lt;code&gt;text-&amp;gt;text in element&lt;/code&gt;和&lt;code&gt;voice-&amp;gt;voice in element&lt;/code&gt;。最简单的方法就是用XPath选取指定的元素。&lt;/p&gt;

&lt;p&gt;KissXML的NSXMLElement类的父类NSXMLNode有一个通过XPath选取子元素得数组的方法：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (NSArray *)nodesForXPath:(NSString *)xpath error:(NSError **)error;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;试之，竟然返回为空。。搜之，发现KissXML上已经有人开了issue，还有热心人把&lt;a href=&quot;https://github.com/tipbit/KissXML/commit/48701f10befe903237db12af726a93041d19d244&quot;&gt;代码&lt;/a&gt;都补上了，这个世界上还是好人多啊。&lt;/p&gt;

&lt;p&gt;前面的方法不能是因为&lt;code&gt;&amp;lt;params/&amp;gt;&lt;/code&gt;中设置了namespace,需要为元素注册这个namespace，所以修改后的方法为：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (NSArray *)nodesForXPath:(NSString *)xpath namespaceMappings:(NSDictionary*)namespaceMappings error:(NSError **)error
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第一步： 在namespaceMappings中设置一个命名空间的别名,如这样的：@{@&quot;prefix&quot;:@&quot;namespace&quot;} ；&lt;/p&gt;

&lt;p&gt;第二步： 在XPath中使用别名 &lt;code&gt;//prefix:param&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;NSString *xmlstring =   @&quot;&amp;lt;params xmlns=\&quot;namespace\&quot; &amp;gt;&quot;
                        @&quot;&amp;lt;param name=\&quot;text\&quot;&amp;gt;text in element&amp;lt;/param&amp;gt;&quot;
                        @&quot;&amp;lt;param name=\&quot;voice\&quot;&amp;gt;voice in element&amp;lt;/param&amp;gt;&quot;
                        @&quot;&amp;lt;/params&amp;gt;&quot;;

NSXMLElement *element = [[NSXMLElement alloc] initWithXMLString:xmlstring error:nil];

NSDictionary *namespaceMap= @{@&quot;prefix&quot;:@&quot;namespace&quot;};
NSArray *subelements = [element nodesForXPath:@&quot;//prefix:param&quot; namespaceMappings:namespaceMap  error:nil];
for (NSXMLElement *e in subelements) {
    NSLog(@&quot;sublelement: %@&quot;, [e XMLString]);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以选到&lt;code&gt;&amp;lt;param/&amp;gt;&lt;/code&gt;子元素了。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;2013-08-01 17:35:04.624 ChatModule[14387:c07] sublelement: &amp;lt;param name=&quot;text&quot;&amp;gt;text in element&amp;lt;/param&amp;gt;
2013-08-01 17:35:04.625 ChatModule[14387:c07] sublelement: &amp;lt;param name=&quot;voice&quot;&amp;gt;voice in element&amp;lt;/param&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;进一步的，如果想要选择&lt;code&gt;name&lt;/code&gt;是&lt;code&gt;text&lt;/code&gt;的&lt;code&gt;&amp;lt;param/&amp;gt;&lt;/code&gt;元素，可以使用更精确的XPath: &lt;code&gt;//prefix:param[@name='text']&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;关于为什么要注册namespace，还需要读libxml2的代码，后面抽时间看一下，改动后的代码中加了这么一段：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if (namespaceMappings) {
    for (NSString* k in namespaceMappings) {
        NSString* v = [namespaceMappings objectForKey:k];
        xmlXPathRegisterNs(xpathCtx, [k xmlChar], [v xmlChar]);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;看SO上有人直接用libxml2的时候也有这个问题，&lt;a href=&quot;http://stackoverflow.com/questions/3744059/xpath-query-for-a-node&quot;&gt;xpath-query-for-a-node&lt;/a&gt; 。&lt;/p&gt;

&lt;p&gt;关于XPath的语法，&lt;a href=&quot;http://www.w3school.com.cn/xpath/xpath_syntax.asp&quot;&gt;戳这里&lt;/a&gt; .&lt;/p&gt;

&lt;p&gt;完。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>SleekXMPP初识</title>
     <link href="http://beiyuu.com/SleekXMPP%E5%88%9D%E8%AF%86"/>
     <updated>2013-07-29T00:00:00+08:00</updated>
     <id>http://beiyuu.com/SleekXMPP初识</id>
     <content type="html">&lt;p&gt;后续需要做一些对XMPP的详细的测试，但是为了能使这些测试能使Android端和Web端也能重用，所以需要选择一个轻量级的库来完成测试任务。自然就想到了强大的Python。跨平台，Mac OSX，Windows都能使用,而且开发效率比较高。&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://sleekxmpp.com/&quot;&gt;SleekXMPP&lt;/a&gt;是一个用python写成的XMPP库。在《XMPP: The Definitive Guide》一书中，作者就用SleekXMPP作为示例。&lt;/p&gt;

&lt;h2&gt;安装&lt;/h2&gt;

&lt;h4&gt;安装SleekXMPP&lt;/h4&gt;

&lt;p&gt;从Github上取到最新的版本：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone https://github.com/fritzy/SleekXMPP.git
cd SleekXMPP
sudo python setup.py install
&lt;/code&gt;&lt;/pre&gt;

&lt;h4&gt;安装DNSPython&lt;/h4&gt;

&lt;p&gt;用于解析DNS服务器，获取XMPP服务端的信息。具体文档&lt;a href=&quot;http://wiki.xmpp.org/web/SRV_Records&quot;&gt;XMPP_SRV_Records&lt;/a&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;git clone http://github.com/rthalley/dnspython
cd dnspython
python setup.py install
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;示例&lt;/h2&gt;

&lt;p&gt;以下是官网中的例子，客户端收到一条消息后，立即返回一条信息。其中用到了&lt;code&gt;msg.reply&lt;/code&gt;,是一个有意思的方法，将&lt;code&gt;message&lt;/code&gt;中的to和from对调，这样就可以很方便的设置message的to和from属性值,库中还有很多方便的函数，总体来说API非常的友好。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/python
#!--*-- coding: UTF-8 --*--

import logging

from sleekxmpp import ClientXMPP
from sleekxmpp.exceptions import IqError, IqTimeout
import threading


class EchoBot(ClientXMPP):

    def __init__(self, jid, password):
        ClientXMPP.__init__(self, jid, password)

        self.add_event_handler(&quot;session_start&quot;, self.session_start)
        self.add_event_handler(&quot;message&quot;, self.message)

    def session_start(self, event):
        self.send_presence()
        self.get_roster()

    def message(self, msg):
        if msg['type'] in ('chat', 'normal'):
            msg.reply(&quot;Thanks for sending\n%(body)s&quot; % msg).send()

if __name__ == '__main__':

    logging.basicConfig(level=logging.DEBUG,
                        format='%(levelname)-8s %(message)s')

    xmpp = EchoBot('username', 'password')
    xmpp.connect()

    xmpp.process(block=True)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;参考文档&lt;/h2&gt;

&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://sleekxmpp.com/architecture.html&quot;&gt;SleekXMPP Architecture&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://prosody.im/doc/dns&quot;&gt;DNS Configuration&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

</content>
   </entry>
   
   <entry>
     <title>CoreData - 存储非标准类型</title>
     <link href="http://beiyuu.com/%E5%AD%98%E5%82%A8%E9%9D%9E%E6%A0%87%E5%87%86%E7%B1%BB%E5%9E%8B"/>
     <updated>2013-07-24T00:00:00+08:00</updated>
     <id>http://beiyuu.com/存储非标准类型</id>
     <content type="html">&lt;p&gt;非标准类型表示除CoreData默认支持的类型(int,double,NSString等等)以外的其他类型，比如一个矩形的颜色，还有Frame等，这些量CoreData默认不支持，需要做一些额外的工作使CoreData支持。方法有两种，一是使用NSValueFromater做值转换，把值的一种表现形式转化为另一种表现形式；第二种是在NSManagedObject中使用临时变量存储不支持的类型的变量。两种解决方法的原理其实是类似的，都是把&lt;strong&gt;属性的表现形式转化成CoreData支持的类型&lt;/strong&gt;，然后做持久化。&lt;/p&gt;

&lt;h2&gt;值转换(NSValueTransformer)&lt;/h2&gt;

&lt;p&gt;值转换的原理是将属性通过&lt;code&gt;NSValueTransformer&lt;/code&gt;的一个实例，将值转化为&lt;strong&gt;NSData&lt;/strong&gt;,然后持久化到数据库中。如果使用SQLite，自定义的类型对应数据库中的&lt;code&gt;Blob&lt;/code&gt;类型.&lt;/p&gt;

&lt;p&gt;下面的例子中，我们需要持久化一个CGSize。(在这里需要先用NSValue包装一下，而且这个例子只是演示怎么使用，还有更好的解决方法)&lt;/p&gt;

&lt;p&gt;1.在Model编辑器中设置添加的属性的类型为&lt;code&gt;Transfomable&lt;/code&gt;,然后在DataModel inspector中设置转化类的类名&lt;/p&gt;

&lt;p&gt;2.继承&lt;code&gt;NSValueTransformer&lt;/code&gt;类&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;//RSSizeTransformer.h

@interface RSSizeTransformer : NSValueTransformer
@end

//RSSizeTransformer.m

#import &quot;RSSizeTransformer.h&quot;

@implementation RSSizeTransformer

+ (Class)transformedValueClass {
    return [NSData class];
}

+ (BOOL)allowsReverseTransformation {
    return YES;
}

- (id)transformedValue:(id)value
{
    NSAssert([value class]!=[NSValue class], @&quot;value must be NSValue&quot;);

    NSValue *v = (NSValue*)value;
    CGSize size = v.CGSizeValue;

    NSString *str = NSStringFromCGSize(size);
    return [str dataUsingEncoding:NSUTF8StringEncoding];
}

- (id)reverseTransformedValue:(id)value
{
    NSAssert([value class]!=[NSData class], @&quot;value must be NSValue&quot;);
    NSString *str = [[NSString alloc] initWithData:value
                                          encoding:NSUTF8StringEncoding];
    CGSize size = CGSizeFromString(str);
    return [NSValue valueWithCGSize:size];
}

@end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;http://nshipster.com/nsvaluetransformer/&quot;&gt;NSHipster&lt;/a&gt;有一篇关于&lt;code&gt;NSValueTransformer&lt;/code&gt;的文章。当然&lt;code&gt;NSValueTransformer&lt;/code&gt;也不仅限于在CoreData中使用。Matt(AFNetworking的作者)还提供了一个快捷的&lt;code&gt;TransformerKit&lt;/code&gt;,通过元编程快速的注册一个&lt;code&gt;NSValueTransformer&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;上面的代码还可以这样实现：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[NSValueTransformer registerValueTransformerWithName:sizeTransformerName
                               transformedValueClass:[NSData class]
                  returningTransformedValueWithBlock:^id(id value) {

                      NSValue *v = (NSValue*)value;
                      CGSize size = v.CGSizeValue;

                      NSString *str = NSStringFromCGSize(size);
                      return [str dataUsingEncoding:NSUTF8StringEncoding];
                  }
              allowingReverseTransformationWithBlock:^id(id value) {

                  NSString *str = [[NSString alloc] initWithData:value
                                                        encoding:NSUTF8StringEncoding];
                  CGSize size = CGSizeFromString(str);
                  return [NSValue valueWithCGSize:size];
              }];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通过&lt;a href=&quot;https://github.com/mattt/TransformerKit/blob/master/TransformerKit/NSValueTransformer%2BTransformerKit.m&quot;&gt;NSValueTransformer+TransformerKit&lt;/a&gt;的源码看一下&lt;strong&gt;元编程&lt;/strong&gt;的威力吧。&lt;/p&gt;

&lt;blockquote&gt;&lt;p&gt;   注意：CoreData中，只能使用&lt;code&gt;NSValueTransformer&lt;/code&gt;将值转化为&lt;code&gt;NSData&lt;/code&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2&gt;临时变量(Transient)&lt;/h2&gt;

&lt;p&gt;对临时变量的存取有几种策略。对于获取临时变量来说，有两种情况，一种是&quot;懒加载(On-demand)&quot;，在需要的时候才去计算临时变量的值；另一种是“预计算(Pre-calculated)”，当拿到原始的值后，就立即计算临时变量的值(通常在awakeFromFetch中计算)。如果值比较大，使用“懒加载”更适合一些。对于真正持久化的值来说，有两种方式，一种是“立即更新(Immediate-update)”，每次值改变时就持久化库中，另外一种是“延迟更新(Delayed-update)”，只有当存储ManagedObject的时候才一并更新到持久化库中。&lt;/p&gt;

&lt;h3&gt;On-demand&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;- (NSColor *)color {

    [self willAccessValueForKey:@&quot;color&quot;];
    NSColor *color = [self primitiveColor];
    [self didAccessValueForKey:@&quot;color&quot;];
    if (color == nil) {
        NSData *colorData = [self colorData];
        if (colorData != nil) {
            color = [NSKeyedUnarchiver unarchiveObjectWithData:colorData];
            [self setPrimitiveColor:color];
        }
    }
    return color;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Pre-calculate&lt;/h3&gt;

&lt;p&gt;从持久化库中得到数据后，ManagedObject的&lt;code&gt;awakeFromFetch&lt;/code&gt;方法被调用：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (void)awakeFromFetch {

    [super awakeFromFetch];
    NSData *colorData = [self colorData];
    if (colorData != nil) {
        NSColor *color = [NSKeyedUnarchiver unarchiveObjectWithData:colorData];
        [self setPrimitiveColor:color];
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;属性的访问器中：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;- (NSColor *)color {

    [self willAccessValueForKey:@&quot;color&quot;];
    NSColor *color = [self primitiveColor];
    [self didAccessValueForKey:@&quot;color&quot;];
    return color;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Immediate-update&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;- (void)setColor:(NSColor *)aColor {

    [self willChangeValueForKey:@&quot;color&quot;];
    [self setPrimitiveValue:aColor forKey:@&quot;color&quot;];
    [self didChangeValueForKey:@&quot;color&quot;];
    [self setValue:[NSKeyedArchiver archivedDataWithRootObject:aColor]
                forKey:@&quot;colorData&quot;];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;Delayed-update&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;- (void)setColor:(NSColor *)aColor {

    [self willChangeValueForKey:@&quot;color&quot;];
    [self setPrimitiveValue:aColor forKey:@&quot;color&quot;];
    [self didChangeValueForKey:@&quot;color&quot;];
}

- (void)willSave {

    NSColor *color = [self primitiveValueForKey:@&quot;color&quot;];
    if (color != nil) {
        [self setPrimitiveValue:[NSKeyedArchiver archivedDataWithRootObject:color]
                forKey:@&quot;colorData&quot;];
    }
    else {
        [self setPrimitiveValue:nil forKey:@&quot;colorData&quot;];
    }
    [super willSave];
}
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
   <entry>
     <title>Openfire连接管理器</title>
     <link href="http://beiyuu.com/Openfire%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%E5%99%A8"/>
     <updated>2013-06-01T00:00:00+08:00</updated>
     <id>http://beiyuu.com/Openfire连接管理器</id>
     <content type="html">&lt;h2&gt;ConncetionManager介绍&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;http://www.igniterealtime.org/images/connection-managers.gif&quot; alt=&quot;connection-managers&quot; /&gt;&lt;/p&gt;

&lt;p&gt;连接管理器放在Openfire的前端，用于保持客户端的连接，连接管理器与Openfire之间保持少量的连接，这样，便能减轻Openfire的连接压力。CM与OF之间通过扩展协议传输客户端与服务端的包。&lt;/p&gt;

&lt;h2&gt;协议分析&lt;/h2&gt;

&lt;p&gt;在XEP文档中没有找到CM和OF之间的扩展协议，所以，下面简单的分析一下协议内容。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;[SEND]表示CM发送给OF，[RECV]表示OF发给CM&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;第一步&lt;/strong&gt;：ConnectionWorkerThread创建与OF的TCP连接和XMPP连接。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;stream:stream  xmlns:stream=&quot;http://etherx.jabber.org/streams&quot; 
                xmlns=&quot;jabber:connectionmanager&quot; 
                to=&quot;q6334/Connection Worker - 1&quot; 
                version=&quot;1.0&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CM收到服务端的回应后，将服务端配置的密码和streamID算出SHA-1值，发送&lt;code&gt;&amp;lt;handshake/&amp;gt;&lt;/code&gt;进行验证，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;handshake&amp;gt;5f3129447e25856fa19d83a472237d720492968a&amp;lt;/handshake&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务端验证成功后返回一个空的&lt;code&gt;&amp;lt;handshake/&amp;gt;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;服务端发送设置项:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[RECV]
&amp;lt;iq type=&quot;set&quot; id=&quot;868-16&quot;&amp;gt;
  &amp;lt;configuration xmlns=&quot;http://jabber.org/protocol/connectionmanager&quot;&amp;gt;
    &amp;lt;starttls xmlns=&quot;urn:ietf:params:xml:ns:xmpp-tls&quot;&amp;gt;&amp;lt;/starttls&amp;gt;
    &amp;lt;mechanisms xmlns=&quot;urn:ietf:params:xml:ns:xmpp-sasl&quot;&amp;gt;
      &amp;lt;mechanism&amp;gt;DIGEST-MD5&amp;lt;/mechanism&amp;gt;
      &amp;lt;mechanism&amp;gt;PLAIN&amp;lt;/mechanism&amp;gt;
      &amp;lt;mechanism&amp;gt;ANONYMOUS&amp;lt;/mechanism&amp;gt;
      &amp;lt;mechanism&amp;gt;CRAM-MD5&amp;lt;/mechanism&amp;gt;
    &amp;lt;/mechanisms&amp;gt;
    &amp;lt;compression xmlns=&quot;http://jabber.org/features/compress&quot;&amp;gt;
      &amp;lt;method&amp;gt;zlib&amp;lt;/method&amp;gt;
    &amp;lt;/compression&amp;gt;
    &amp;lt;auth xmlns=&quot;http://jabber.org/features/iq-auth&quot;&amp;gt;&amp;lt;/auth&amp;gt;
    &amp;lt;register xmlns=&quot;http://jabber.org/features/iq-register&quot;&amp;gt;&amp;lt;/register&amp;gt;
  &amp;lt;/configuration&amp;gt;
&amp;lt;/iq&amp;gt;

[SEND]
&amp;lt;iq type=&quot;result&quot; id=&quot;868-16&quot; to=&quot;openfire.irusher.com&quot; from=&quot;q6334/Connection Worker - 1&quot;&amp;gt;
  &amp;lt;configuration xmlns=&quot;http://jabber.org/protocol/connectionmanager&quot;&amp;gt;
    &amp;lt;starttls xmlns=&quot;urn:ietf:params:xml:ns:xmpp-tls&quot;&amp;gt;&amp;lt;/starttls&amp;gt;
    &amp;lt;mechanisms xmlns=&quot;urn:ietf:params:xml:ns:xmpp-sasl&quot;&amp;gt;
      &amp;lt;mechanism&amp;gt;DIGEST-MD5&amp;lt;/mechanism&amp;gt;
      &amp;lt;mechanism&amp;gt;PLAIN&amp;lt;/mechanism&amp;gt;
      &amp;lt;mechanism&amp;gt;ANONYMOUS&amp;lt;/mechanism&amp;gt;
      &amp;lt;mechanism&amp;gt;CRAM-MD5&amp;lt;/mechanism&amp;gt;
    &amp;lt;/mechanisms&amp;gt;
    &amp;lt;compression xmlns=&quot;http://jabber.org/features/compress&quot;&amp;gt;
      &amp;lt;method&amp;gt;zlib&amp;lt;/method&amp;gt;
    &amp;lt;/compression&amp;gt;
    &amp;lt;auth xmlns=&quot;http://jabber.org/features/iq-auth&quot;&amp;gt;&amp;lt;/auth&amp;gt;
    &amp;lt;register xmlns=&quot;http://jabber.org/features/iq-register&quot;&amp;gt;&amp;lt;/register&amp;gt;
  &amp;lt;/configuration&amp;gt;
&amp;lt;/iq&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;第二步&lt;/strong&gt;：客户端连接CM后，建立CM与OF之间的会话&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[SEND]
&amp;lt;iq type=&quot;set&quot; to=&quot;openfire.irusher.com&quot; from=&quot;q6334/Connection Worker - 1&quot; id=&quot;234-0&quot;&amp;gt;
  &amp;lt;session xmlns=&quot;http://jabber.org/protocol/connectionmanager&quot; id=&quot;q63347a14e957&quot;&amp;gt;
    &amp;lt;create&amp;gt;
      &amp;lt;host name=&quot;localhost&quot; address=&quot;127.0.0.1&quot;/&amp;gt;
    &amp;lt;/create&amp;gt;
  &amp;lt;/session&amp;gt;
&amp;lt;/iq&amp;gt;


[RECV]  
&amp;lt;iq type=&quot;result&quot; id=&quot;234-0&quot; from=&quot;openfire.irusher.com&quot; to=&quot;q6334/Connection Worker - 1&quot;&amp;gt;
  &amp;lt;session xmlns=&quot;http://jabber.org/protocol/connectionmanager&quot; id=&quot;q63347a14e957&quot;&amp;gt;
    &amp;lt;create&amp;gt;
      &amp;lt;host name=&quot;localhost&quot; address=&quot;127.0.0.1&quot;/&amp;gt;
    &amp;lt;/create&amp;gt;
  &amp;lt;/session&amp;gt;
&amp;lt;/iq&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;CM与OF的会话建立之后，客户端与OF之间的XMPP包内容，都被包含在&lt;code&gt;&amp;lt;route/&amp;gt;&lt;/code&gt;标签内，同时，标签还带有一个'streamid'属性，用于标识客户端的会话。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[SEND]
&amp;lt;route to=&quot;openfire.irusher.com&quot; from=&quot;q6334/Connection Worker - 1&quot; streamid=&quot;q63347a14e957&quot;&amp;gt;
  &amp;lt;auth xmlns=&quot;urn:ietf:params:xml:ns:xmpp-sasl&quot; mechanism=&quot;DIGEST-MD5&quot;&amp;gt;&amp;lt;/auth&amp;gt;
&amp;lt;/route&amp;gt;

[RECV]
&amp;lt;route from=&quot;openfire.irusher.com&quot; to=&quot;q6334&quot; streamid=&quot;q63347a14e957&quot;&amp;gt;
  &amp;lt;challenge xmlns=&quot;urn:ietf:params:xml:ns:xmpp-sasl&quot;&amp;gt;cmVhbG09Im9wZW5maXJlLmlydXNoZXIuY29tIixub25jZT0iLytPaWQ1QWNLdXduTFJqbGZZNmZNU1pzeWJuSlVUdVlUMUFqRExWayIscW9wPSJhdXRoIixjaGFyc2V0PXV0Zi04LGFsZ29yaXRobT1tZDUtc2Vzcw==&amp;lt;/challenge&amp;gt;
&amp;lt;/route&amp;gt;

[SEND]  
 &amp;lt;route to=&quot;openfire.irusher.com&quot; from=&quot;q6334/Connection Worker - 1&quot; streamid=&quot;q63347a14e957&quot;&amp;gt;
   &amp;lt;response xmlns=&quot;urn:ietf:params:xml:ns:xmpp-sasl&quot;&amp;gt;dXNlcm5hbWU9InJvYm90YSIscmVhbG09Im9wZW5maXJlLmlydXNoZXIuY29tIixub25jZT0iLytPaWQ1QWNLdXduTFJqbGZZNmZNU1pzeWJuSlVUdVlUMUFqRExWayIsY25vbmNlPSI5NjA2Q0I1NS04NDQ1LTQ4MzAtOTE1My0wMkQxMTQ5RTM2RkIiLG5jPTAwMDAwMDAxLHFvcD1hdXRoLGRpZ2VzdC11cmk9InhtcHAvb3BlbmZpcmUuaXJ1c2hlci5jb20iLHJlc3BvbnNlPWNiZWRmZmUyMDg1MmQ3NmEwYzkzZTJjYTk5OGE4ZWUwLGNoYXJzZXQ9dXRmLTg=&amp;lt;/response&amp;gt;
 &amp;lt;/route&amp;gt;

 [RECV]  
 &amp;lt;route from=&quot;openfire.irusher.com&quot; to=&quot;q6334&quot; streamid=&quot;q63347a14e957&quot;&amp;gt;
   &amp;lt;success xmlns=&quot;urn:ietf:params:xml:ns:xmpp-sasl&quot;&amp;gt;cnNwYXV0aD0yYWIzOTkyYTQ2YjYzZWJhZWUwZDNjYTc1MjAzZThiZg==&amp;lt;/success&amp;gt;
 &amp;lt;/route&amp;gt;  

 [SEND]
 &amp;lt;route to=&quot;openfire.irusher.com&quot; from=&quot;q6334/Connection Worker - 1&quot; streamid=&quot;q63347a14e957&quot;&amp;gt;
   &amp;lt;iq type=&quot;set&quot;&amp;gt;
     &amp;lt;bind xmlns=&quot;urn:ietf:params:xml:ns:xmpp-bind&quot;&amp;gt;&amp;lt;/bind&amp;gt;
   &amp;lt;/iq&amp;gt;
 &amp;lt;/route&amp;gt;  

 [RECV]
 &amp;lt;route streamid=&quot;q63347a14e957&quot; from=&quot;openfire.irusher.com&quot; to=&quot;q6334&quot;&amp;gt;
   &amp;lt;iq type=&quot;result&quot; to=&quot;openfire.irusher.com/q63347a14e957&quot;&amp;gt;
     &amp;lt;bind xmlns=&quot;urn:ietf:params:xml:ns:xmpp-bind&quot;&amp;gt;
       &amp;lt;jid&amp;gt;robota@openfire.irusher.com/q63347a14e957&amp;lt;/jid&amp;gt;
     &amp;lt;/bind&amp;gt;
   &amp;lt;/iq&amp;gt;
 &amp;lt;/route&amp;gt;  

 [SEND]
 &amp;lt;route to=&quot;openfire.irusher.com&quot; from=&quot;q6334/Connection Worker - 1&quot; streamid=&quot;q63347a14e957&quot;&amp;gt;
   &amp;lt;iq type=&quot;set&quot;&amp;gt;
     &amp;lt;session xmlns=&quot;urn:ietf:params:xml:ns:xmpp-session&quot;&amp;gt;&amp;lt;/session&amp;gt;
   &amp;lt;/iq&amp;gt;
 &amp;lt;/route&amp;gt;  

 [RECV]
 &amp;lt;route streamid=&quot;q63347a14e957&quot; from=&quot;openfire.irusher.com&quot; to=&quot;q6334&quot;&amp;gt;
   &amp;lt;iq type=&quot;result&quot; to=&quot;robota@openfire.irusher.com/q63347a14e957&quot;/&amp;gt;
 &amp;lt;/route&amp;gt;  

 [SEND]
 &amp;lt;route to=&quot;openfire.irusher.com&quot; from=&quot;q6334/Connection Worker - 1&quot; streamid=&quot;q63347a14e957&quot;&amp;gt;
   &amp;lt;iq type=&quot;get&quot;&amp;gt;
     &amp;lt;query xmlns=&quot;jabber:iq:roster&quot;&amp;gt;&amp;lt;/query&amp;gt;
   &amp;lt;/iq&amp;gt;
 &amp;lt;/route&amp;gt;  

 [RECV]
 &amp;lt;route streamid=&quot;q63347a14e957&quot; from=&quot;openfire.irusher.com&quot; to=&quot;q6334&quot;&amp;gt;
   &amp;lt;iq type=&quot;result&quot; to=&quot;robota@openfire.irusher.com/q63347a14e957&quot;&amp;gt;
     &amp;lt;query xmlns=&quot;jabber:iq:roster&quot;&amp;gt;
       &amp;lt;item jid=&quot;robotx@openfire.irusher.com&quot; ask=&quot;subscribe&quot; subscription=&quot;from&quot;/&amp;gt;
       &amp;lt;item jid=&quot;robotb@openfire.irusher.com&quot; name=&quot;robotb&quot; subscription=&quot;both&quot;&amp;gt;
         &amp;lt;group&amp;gt;Friends&amp;lt;/group&amp;gt;
       &amp;lt;/item&amp;gt;
     &amp;lt;/query&amp;gt;
   &amp;lt;/iq&amp;gt;
 &amp;lt;/route&amp;gt;  

 [SEND]
 &amp;lt;route to=&quot;openfire.irusher.com&quot; from=&quot;q6334/Connection Worker - 1&quot; streamid=&quot;q63347a14e957&quot;&amp;gt;
   &amp;lt;iq type=&quot;get&quot; to=&quot;robota@openfire.irusher.com&quot;&amp;gt;
     &amp;lt;vCard xmlns=&quot;vcard-temp&quot;&amp;gt;&amp;lt;/vCard&amp;gt;
   &amp;lt;/iq&amp;gt;
 &amp;lt;/route&amp;gt;  

 [SEND]
 &amp;lt;route to=&quot;openfire.irusher.com&quot; from=&quot;q6334/Connection Worker - 1&quot; streamid=&quot;q63347a14e957&quot;&amp;gt;
   &amp;lt;presence&amp;gt;
     &amp;lt;x xmlns=&quot;vcard-temp:x:update&quot;&amp;gt;
       &amp;lt;photo/&amp;gt;
     &amp;lt;/x&amp;gt;
     &amp;lt;c xmlns=&quot;http://jabber.org/protocol/caps&quot; hash=&quot;sha-1&quot; node=&quot;http://code.google.com/p/xmppframework&quot; ver=&quot;k6gP4Ua5m4uu9YorAG0LRXM+kZY=&quot;&amp;gt;&amp;lt;/c&amp;gt;
   &amp;lt;/presence&amp;gt;
 &amp;lt;/route&amp;gt;  

 [RECV]
 &amp;lt;route streamid=&quot;q63347a14e957&quot; from=&quot;openfire.irusher.com&quot; to=&quot;q6334&quot;&amp;gt;
   &amp;lt;iq type=&quot;result&quot; from=&quot;robota@openfire.irusher.com&quot; to=&quot;robota@openfire.irusher.com/q63347a14e957&quot;&amp;gt;
     &amp;lt;vCard xmlns=&quot;vcard-temp&quot;&amp;gt;&amp;lt;/vCard&amp;gt;
   &amp;lt;/iq&amp;gt;
 &amp;lt;/route&amp;gt;  

 [SEND]
 &amp;lt;route to=&quot;openfire.irusher.com&quot; from=&quot;q6334/Connection Worker - 1&quot; streamid=&quot;q63347a14e957&quot;&amp;gt;
   &amp;lt;presence&amp;gt;
     &amp;lt;x xmlns=&quot;vcard-temp:x:update&quot;&amp;gt;
       &amp;lt;photo/&amp;gt;
     &amp;lt;/x&amp;gt;
     &amp;lt;c xmlns=&quot;http://jabber.org/protocol/caps&quot; hash=&quot;sha-1&quot; node=&quot;http://code.google.com/p/xmppframework&quot; ver=&quot;k6gP4Ua5m4uu9YorAG0LRXM+kZY=&quot;&amp;gt;&amp;lt;/c&amp;gt;
     &amp;lt;x xmlns=&quot;vcard-temp:x:update&quot;&amp;gt;
       &amp;lt;photo/&amp;gt;
     &amp;lt;/x&amp;gt;
     &amp;lt;c xmlns=&quot;http://jabber.org/protocol/caps&quot; hash=&quot;sha-1&quot; node=&quot;http://code.google.com/p/xmppframework&quot; ver=&quot;k6gP4Ua5m4uu9YorAG0LRXM+kZY=&quot;&amp;gt;&amp;lt;/c&amp;gt;
   &amp;lt;/presence&amp;gt;
 &amp;lt;/route&amp;gt;  

 [SEND]
 &amp;lt;route to=&quot;openfire.irusher.com&quot; from=&quot;q6334/Connection Worker - 1&quot; streamid=&quot;q63347a14e957&quot;&amp;gt;
   &amp;lt;message type=&quot;chat&quot; to=&quot;robotb@openfire.irusher.com&quot; from=&quot;robota@openfire.irusher.com/q63347a14e957&quot; id=&quot;13053016172881&quot;&amp;gt;
     &amp;lt;body&amp;gt;ABC&amp;lt;/body&amp;gt;
   &amp;lt;/message&amp;gt;
 &amp;lt;/route&amp;gt;  

 [RECV]
 &amp;lt;route streamid=&quot;q63347a14e957&quot; from=&quot;openfire.irusher.com&quot; to=&quot;q6334&quot;&amp;gt;
   &amp;lt;message to=&quot;robota@openfire.irusher.com/q63347a14e957&quot; from=&quot;admin@openfire.irusher.com&quot; type=&quot;chat&quot;&amp;gt;
     &amp;lt;received xmlns=&quot;http://yonglang.co/xmpp/server/reveived&quot; id=&quot;13053016172881&quot; timestamp=&quot;2013-05-30T16:17:28Z&quot;&amp;gt;&amp;lt;/received&amp;gt;
   &amp;lt;/message&amp;gt;
 &amp;lt;/route&amp;gt;  

 [SEND]
 &amp;lt;route to=&quot;openfire.irusher.com&quot; from=&quot;q6334/Connection Worker - 1&quot; streamid=&quot;q63347a14e957&quot;&amp;gt;
   &amp;lt;presence type=&quot;unavailable&quot;&amp;gt;
     &amp;lt;x xmlns=&quot;vcard-temp:x:update&quot;&amp;gt;
       &amp;lt;photo/&amp;gt;
     &amp;lt;/x&amp;gt;
   &amp;lt;/presence&amp;gt;
 &amp;lt;/route&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;结束&lt;/strong&gt;：客户端断开连接，CM和OF关闭会话。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; [SEND]
 &amp;lt;iq type=&quot;set&quot; to=&quot;openfire.irusher.com&quot; from=&quot;q6334/Connection Worker - 1&quot; id=&quot;784-1&quot;&amp;gt;
   &amp;lt;session xmlns=&quot;http://jabber.org/protocol/connectionmanager&quot; id=&quot;q63347a14e957&quot;&amp;gt;
     &amp;lt;close/&amp;gt;
   &amp;lt;/session&amp;gt;
 &amp;lt;/iq&amp;gt;  

 [RECV]
 &amp;lt;iq type=&quot;result&quot; id=&quot;784-1&quot; from=&quot;openfire.irusher.com&quot; to=&quot;q6334/Connection Worker - 1&quot;&amp;gt;
   &amp;lt;session xmlns=&quot;http://jabber.org/protocol/connectionmanager&quot; id=&quot;q63347a14e957&quot;&amp;gt;
     &amp;lt;close/&amp;gt;
   &amp;lt;/session&amp;gt;
 &amp;lt;/iq&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;代码结构&lt;/h2&gt;

&lt;p&gt;CM和Openfire都是基于Mina框架。&lt;/p&gt;

&lt;p&gt;代码示意图：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://irusher.com/images/openfire/cm_architecture.png&quot; alt=&quot;cm_architecture.png&quot; /&gt;&lt;/p&gt;

&lt;h3&gt;连接与会话&lt;/h3&gt;

&lt;h4&gt;1.客户端与CM的TCP连接&lt;/h4&gt;

&lt;p&gt;CM建立一个&lt;code&gt;SocketAcceptor&lt;/code&gt;，用于接受客户端的Socket,设置多线程模式,使用线程池中的线程接受客户端发来的XML内容。为&lt;code&gt;SocketAcceptor&lt;/code&gt;绑定一个&lt;code&gt;ClientConnectionHandler&lt;/code&gt;。&lt;code&gt;ClientConnectionHandler&lt;/code&gt;是&lt;code&gt;IoHandlerAdapter&lt;/code&gt;的一个实现类，可以对客户端的会话事件进行处理:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;void exceptionCaught(IoSession session, Throwable cause)
void messageReceived(IoSession session, Object message)
void messageSent(IoSession session, Object message)
void sessionClosed(IoSession session)
void sessionCreated(IoSession session)
void sessionIdle(IoSession session, IdleStatus status)
void sessionOpened(IoSession session)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;ClientConnectionHandler&lt;/code&gt;主要完成连接的建立(&lt;code&gt;NIOConnection&lt;/code&gt;)，XML解析器(&lt;code&gt;XmlPullParser&lt;/code&gt;)，XMPP协议操作类(&lt;code&gt;ClientStanzaHandler&lt;/code&gt;)的建立，以及连接关闭时资源的释放。当CM收到客户端的消息后，具体的XMPP协议解析交给&lt;code&gt;ClientStanzaHandler&lt;/code&gt;完成。&lt;code&gt;ClientStanzaHandler&lt;/code&gt;通过解析XML的内容完成以下工作：&lt;/p&gt;

&lt;ol type=&quot;a&quot;&gt;
&lt;li&gt;建立CM与OF的会话(&lt;code&gt;ClientSession&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;建立客户端与CM之间的XMPP连接&lt;/li&gt;
&lt;li&gt;判断是否使用TLS，流压缩&lt;/li&gt;
&lt;li&gt;将消息交与&lt;code&gt;ServerRouter&lt;/code&gt;处理。&lt;/li&gt;
&lt;/ol&gt;


&lt;h4&gt;2.CM与OF连接&lt;/h4&gt;

&lt;p&gt;CM与OF之间保持少量的TCP连接，默认是5个，连接所在的线程由线程池维护，连接池由类&lt;code&gt;ServerSurrogate&lt;/code&gt;保持，在&lt;code&gt;ConnectionManager&lt;/code&gt;启动的时候启动连接池。每个&lt;code&gt;ConnectionWorkerThread&lt;/code&gt;线程建立一个TCP连接，在这之上建立XMPP协议层的连接(&lt;a href=&quot;http://xmpp.org/extensions/xep-0114.html&quot;&gt;XEP-0114: Jabber Component Protocol&lt;/a&gt;),协议内容已经在&lt;strong&gt;协议分析&lt;/strong&gt;中提到。&lt;/p&gt;

&lt;p&gt;CM与OF连接的Socket由&lt;code&gt;SocketConnection&lt;/code&gt;持有，此类负责向Socket写或者从Socket读取数据。&lt;/p&gt;

&lt;p&gt;Socket的字节输入流经过字节流字符流转换类流入&lt;code&gt;XMPPPacketReader&lt;/code&gt;类，再由&lt;code&gt;ServerPacketReader&lt;/code&gt;的后台线程读取，建立线程池，在多个线程中用&lt;code&gt;ServerPacketHandler&lt;/code&gt;处理XMPP协议。协议内容已经在&lt;strong&gt;协议分析&lt;/strong&gt;中提到，在XMPP连接初始建立的时候，&lt;code&gt;ServerPacketHandler&lt;/code&gt;通过解析XML内容来决定&lt;code&gt;SocketConnection&lt;/code&gt;是否使用安全连接，是否压缩等特性。&lt;/p&gt;

&lt;h4&gt;3.CM与OF建立新的会话&lt;/h4&gt;

&lt;p&gt;CM与OF之间只是传输的作用，并没有其他的业务逻辑，所有的客户端发向OF的XMPP协议内容，都被包裹在'&lt;route/&gt;'元素中。但是由于是多个客户端的内容通过少量的连接发向OF，所以对内容进行标识，以保证服务端的回复内容返回到正确的客户端。在&lt;strong&gt;1.a&lt;/strong&gt;中提到&lt;code&gt;ClientStanzaHandler&lt;/code&gt;通过解析XML的内容建立CM与OF的会话(&lt;code&gt;ClientSession&lt;/code&gt;)，每个会话内使用相同的&lt;code&gt;streamdid&lt;/code&gt;,作为'&lt;route/&gt;'元素的属性，来标识不同的客户端。&lt;code&gt;ClientSession&lt;/code&gt;的超类&lt;code&gt;Session&lt;/code&gt;持有一个静态的HashMap，以&lt;code&gt;streamid&lt;/code&gt;为键，&lt;code&gt;ClientSession&lt;/code&gt;(或者&lt;code&gt;HttpSession&lt;/code&gt;，在&lt;strong&gt;BOSH&lt;/strong&gt;中涉及)为值，这样就可以方便的获取到&lt;code&gt;streamid&lt;/code&gt;对应的会话了。&lt;/p&gt;

&lt;h3&gt;消息流转&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;ServerSurrogate&lt;/code&gt;代理转发所有流向服务器的数据。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;SocketSenderTracker&lt;/code&gt;定时扫描CM与OF之间的连接，检查连接是否可用。&lt;/p&gt;
</content>
   </entry>
   
   <entry>
     <title>Smack解析自定义包结构</title>
     <link href="http://beiyuu.com/Smack%E8%A7%A3%E6%9E%90%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%85%E7%BB%93%E6%9E%84"/>
     <updated>2013-05-16T00:00:00+08:00</updated>
     <id>http://beiyuu.com/Smack解析自定义包结构</id>
     <content type="html">&lt;h2&gt;需求&lt;/h2&gt;

&lt;p&gt;XMPP发展这么多年来，积累了很多的扩展协议，涉及到方方面面。尽管如此，有时候，还是需要自定义协议内容来满足业务上的需求。例如：&lt;/p&gt;

&lt;p&gt;在聊天应用中，需要发送不同类型的消息，如文字消息，图片消息，声音消息等等。每一种消息除了有公用的属性外，还有一些自己的属性，例如图片消息，需要发送图片上传到的URL，图片的尺寸，图片的大小等等，而声音消息可能会带上音频文件的格式，以及长短等等,解决方案如下&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;message type=&quot;chat&quot; to=&quot;robota@openfire.irusher.com&quot; from=&quot;robotb@openfire.irusher.com/c3f953be&quot; id=&quot;13051615553429&quot;&amp;gt;
  &amp;lt;body/&amp;gt;
  &amp;lt;params xmlns=&quot;yl:xmpp:params&quot;&amp;gt;
    &amp;lt;param name=&quot;type&quot;&amp;gt;1&amp;lt;/param&amp;gt;
    &amp;lt;param name=&quot;url&quot;&amp;gt;some_url&amp;lt;/param&amp;gt;
    &amp;lt;param name=&quot;width&quot;&amp;gt;100&amp;lt;/param&amp;gt;
    &amp;lt;param name=&quot;height&quot;&amp;gt;200&amp;lt;/param&amp;gt;
  &amp;lt;/params&amp;gt;
&amp;lt;/message&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;对于smack来说，body,thread,subject,error,properties 之外的子元素，都需要用提供包扩展来指定解析。&lt;/p&gt;

&lt;h2&gt;smack的提供者架构：包扩展(Packet Extensions)与自定义IQ&lt;/h2&gt;

&lt;p&gt;Smack的提供者架构是一种模块化的机制，包括为解析自定义包结构而定义的包扩展和自定义IQ包。Smack扩展协议所用的正式提供者架构。现有的两种提供者：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;IQProvider&lt;/strong&gt;: 解析IQ包，封装成Java对象；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;PacketExtension&lt;/strong&gt;: 解析XML子文档，封装到PacketExtension对象，然后赋给包对象。&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;IQProvider&lt;/h3&gt;

&lt;p&gt;默认的，Smack只知道子包的命名空间是下面列表中的IQ包：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;jabber:iq:auth&lt;/li&gt;
&lt;li&gt;jabber:iq:roster&lt;/li&gt;
&lt;li&gt;jabber:iq:register&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;由于XMPP和扩展协议中还有很多其他类型的IQ,所以需要一种灵活的解析机制。注册IQ提供者有两种方式：通过程序注册；在Jar包的META-INF目录添加&lt;strong&gt;smack.providers&lt;/strong&gt;文件。文件是一个XML文件，可以包含若干个iqProvider项，格式如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
 &amp;lt;smackProviders&amp;gt;
     &amp;lt;iqProvider&amp;gt;
         &amp;lt;elementName&amp;gt;query&amp;lt;/elementName&amp;gt;
         &amp;lt;namespace&amp;gt;jabber:iq:time&amp;lt;/namespace&amp;gt;
         &amp;lt;className&amp;gt;org.jivesoftware.smack.packet.Time&amp;lt;/className&amp;gt;
     &amp;lt;/iqProvider&amp;gt;
 &amp;lt;/smackProviders&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;每个IQ提供者对应一个元素名称和一个命名空间。上面的例子中，元素名称是'query',命名空间是'jabber:iq:time'。如果有出现重名，则使用先从classpath中加载的类。&lt;/p&gt;

&lt;p&gt;IQ提供者类可以实现&lt;code&gt;IQProvider&lt;/code&gt;接口，或者继承&lt;code&gt;IQ&lt;/code&gt;类。实现&lt;code&gt;IQProvider&lt;/code&gt;接口时，每个&lt;code&gt;IQProvider&lt;/code&gt;负责解析原始的XML流，然后创建&lt;code&gt;IQ&lt;/code&gt;对象；如果继承&lt;code&gt;IQ&lt;/code&gt;类，则在解析XML过程中，利用Bean自省设置&lt;code&gt;IQ&lt;/code&gt;实例的值。例如，下面这个XMPP包：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;iq type='result' to='joe@example.com' from='mary@example.com' id='time_1'&amp;gt;
    &amp;lt;query xmlns='jabber:iq:time'&amp;gt;
        &amp;lt;utc&amp;gt;20020910T17:58:35&amp;lt;/utc&amp;gt;
        &amp;lt;tz&amp;gt;MDT&amp;lt;/tz&amp;gt;
        &amp;lt;display&amp;gt;Tue Sep 10 12:58:35 2002&amp;lt;/display&amp;gt;
    &amp;lt;/query&amp;gt;
&amp;lt;/iq&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;为了能使包自动映射到上面提到的Time对象，Time对象必需设置utc,tz,display的set方法。自省服务将试着自动的将XML中的String值转化为boolean,int,long,float,double或者IQ对象需要的Class。&lt;/p&gt;

&lt;h3&gt;PacketExtensionProvider&lt;/h3&gt;

&lt;p&gt;包扩展提供者为自定义包提供了一个灵活的插件系统，这样，&lt;code&gt;IQ&lt;/code&gt;,&lt;code&gt;Message&lt;/code&gt;,&lt;code&gt;Presence&lt;/code&gt;中自定义的子元素就可以被解析/XML化。每个扩展的提供者需要在&lt;strong&gt;smack.providers&lt;/strong&gt;文件中注册一个elementName和namespace，如下：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
&amp;lt;smackProviders&amp;gt;
    &amp;lt;extensionProvider&amp;gt;
        &amp;lt;elementName&amp;gt;x&amp;lt;/elementName&amp;gt;
        &amp;lt;namespace&amp;gt;jabber:iq:event&amp;lt;/namespace&amp;gt;
        &amp;lt;className&amp;gt;org.jivesoftware.smack.packet.MessageEvent&amp;lt;/className&amp;gt;
    &amp;lt;/extensionProvider&amp;gt;
&amp;lt;/smackProviders&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果有出现重名，则使用先从classpath中加载的类。&lt;/p&gt;

&lt;p&gt;当一个包中有自定义的元素，解析任务将由对应的提供者接管。提供者可以实现&lt;code&gt;PacketExtensionProvider&lt;/code&gt;接口，或者使标准的Java Bean。前一种情况，每个扩展提供者负责解析原始的XML流，然后构造出一个包扩展对象。后一种情况，将使用Bean自省自动设置包扩展对象的属性值。&lt;/p&gt;

&lt;p&gt;如果一个包扩展没有对应的提供者被注册，Smack将存储存储子包中的所有顶层子XML元素到&lt;code&gt;DefaultPacketExtension&lt;/code&gt;对象，然后赋值给&lt;code&gt;Packet&lt;/code&gt;对象。&lt;/p&gt;

&lt;h3&gt;程序内注册提供者&lt;/h3&gt;

&lt;p&gt;使用&lt;code&gt;org.jivesoftware.smack.provider.ProviderManager&lt;/code&gt;类的单例，&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;注册自定义的&lt;code&gt;IQProvider&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;void addIQProvider(java.lang.String elementName, java.lang.String namespace, java.lang.Object provider)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void removeIQProvider(java.lang.String elementName, java.lang.String namespace)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;注册自定义的&lt;code&gt;PacketExtensionProvider&lt;/code&gt;:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;addExtensionProvider(java.lang.String elementName, java.lang.String namespace, java.lang.Object provider)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void removeExtensionProvider(java.lang.String elementName, java.lang.String namespace)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;默认元素&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;IQ&lt;/code&gt;,&lt;code&gt;Message&lt;/code&gt;,&lt;code&gt;Presence&lt;/code&gt;中包含的一些子元素，已经由Smack解析，通常，这些元素都是基本的XMPP定义的元素，所以，不推荐对这些元素进行修改和扩展。&lt;/p&gt;

&lt;h3&gt;Maven打包复制文件到META-INF目录&lt;/h3&gt;

&lt;p&gt;在src/main/resources目录下建一个META-INF目录，然后把smack.providers文件复制到这个目录，然后运行&lt;code&gt;mvn package&lt;/code&gt;的时候，Maven自动把这个目录下的的文件拷到jar包的META-INF目录下。&lt;/p&gt;

&lt;h4&gt;IQ&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;ElementName &lt;/th&gt;
&lt;th style=&quot;text-align:center;&quot;&gt; Namespace&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;query&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;jabber:iq:auth&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;query&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;jabber:iq:roster&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;query&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;jabber:iq:register&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;error&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;以及，其他在&lt;em&gt;smack.providers&lt;/em&gt;文件中已经注册的元素和命名空间&lt;/p&gt;

&lt;h4&gt;Message&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;ElementName &lt;/th&gt;
&lt;th style=&quot;text-align:center;&quot;&gt; Namespace&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;subject&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;body&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;thread&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;error&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;properties&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;http://www.jivesoftware.com/xmlns/xmpp/properties&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;以及，其他在&lt;em&gt;smack.providers&lt;/em&gt;文件中已经注册的元素和命名空间&lt;/p&gt;

&lt;h4&gt;Precense&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;ElementName &lt;/th&gt;
&lt;th style=&quot;text-align:center;&quot;&gt; Namespace&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;status&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;priority&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;show&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;error&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;无&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;properties&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;http://www.jivesoftware.com/xmlns/xmpp/properties&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;以及，其他在&lt;em&gt;smack.providers&lt;/em&gt;文件中已经注册的元素和命名空间&lt;/p&gt;

&lt;h2&gt;smack解析过程&lt;/h2&gt;

&lt;p&gt;1.在PacketReader中解析&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Parse top-level packets in order to process them further.
 *
 * @param thread the thread that is being used by the reader to parse incoming packets.
 */
private void parsePackets(Thread thread) {
    try {
        int eventType = parser.getEventType();
        do {
            if (eventType == XmlPullParser.START_TAG) {
                if (parser.getName().equals(&quot;message&quot;)) {
                    processPacket(PacketParserUtils.parseMessage(parser));
                }
                else if (parser.getName().equals(&quot;iq&quot;)) {
                    processPacket(PacketParserUtils.parseIQ(parser, connection));
                }
                else if (parser.getName().equals(&quot;presence&quot;)) {
                    processPacket(PacketParserUtils.parsePresence(parser));
                }

                … other top-level element
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2，调用PacketParserUtils.parseXXX();&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Parses a message packet.
 *
 * @param parser the XML parser, positioned at the start of a message packet.
 * @return a Message packet.
 * @throws Exception if an exception occurs while parsing the packet.
 */
public static Packet parseMessage(XmlPullParser parser) throws Exception {

    ... 

    // Parse sub-elements. We include extra logic to make sure the values
    // are only read once. This is because it's possible for the names to appear
    // in arbitrary sub-elements.
    boolean done = false;
    String thread = null;
    Map&amp;lt;String, Object&amp;gt; properties = null;
    while (!done) {
        int eventType = parser.next();
        if (eventType == XmlPullParser.START_TAG) {
            String elementName = parser.getName();
            String namespace = parser.getNamespace();
            if (elementName.equals(&quot;subject&quot;)) {
                ...
            }
            else if (elementName.equals(&quot;body&quot;)) {
                ...
            }
            else if (elementName.equals(&quot;thread&quot;)) {
               ...
            }
            else if (elementName.equals(&quot;error&quot;)) {
                ...
            }
            else if (elementName.equals(&quot;properties&quot;) 
                        &amp;amp;&amp;amp; namespace.equals(PROPERTIES_NAMESPACE))

            {
                ...
            }
            // Otherwise, it must be a packet extension.
            else {
                message.addExtension(
                PacketParserUtils.parsePacketExtension(elementName, namespace, parser));
            }
        }
        else if (eventType == XmlPullParser.END_TAG) {
            if (parser.getName().equals(&quot;message&quot;)) {
                done = true;
            }
        }
    }

    ...

    return message;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;3.调用&lt;code&gt;PacketParserUtils.parsePacketExtension(elementName, namespace, parser));&lt;/code&gt;方法，由&lt;code&gt;ProviderManager&lt;/code&gt;查找对应的包扩展提供者，如果找到，则调用扩展的解析方法，如果没有找到，则解析子元素中顶级的元素，然后存到&lt;code&gt;DefaultPacketExtension&lt;/code&gt;的对象中。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;/**
 * Parses a packet extension sub-packet.
 *
 * @param elementName the XML element name of the packet extension.
 * @param namespace the XML namespace of the packet extension.
 * @param parser the XML parser, positioned at the starting element of the extension.
 * @return a PacketExtension.
 * @throws Exception if a parsing error occurs.
 */
public static PacketExtension parsePacketExtension(String elementName, String namespace, XmlPullParser parser)
        throws Exception
{
    // See if a provider is registered to handle the extension.
    Object provider = ProviderManager.getInstance().getExtensionProvider(elementName, namespace);
    if (provider != null) {
        if (provider instanceof PacketExtensionProvider) {
            return ((PacketExtensionProvider)provider).parseExtension(parser);
        }
        else if (provider instanceof Class) {
            return (PacketExtension)parseWithIntrospection(
                    elementName, (Class&amp;lt;?&amp;gt;)provider, parser);
        }
    }
    // No providers registered, so use a default extension.
    DefaultPacketExtension extension = new DefaultPacketExtension(elementName, namespace);
    boolean done = false;
    while (!done) {
        int eventType = parser.next();
        if (eventType == XmlPullParser.START_TAG) {
            String name = parser.getName();
            // If an empty element, set the value with the empty string.
            if (parser.isEmptyElementTag()) {
                extension.setValue(name,&quot;&quot;);
            }
            // Otherwise, get the the element text.
            else {
                eventType = parser.next();
                if (eventType == XmlPullParser.TEXT) {
                    String value = parser.getText();
                    extension.setValue(name, value);
                }
            }
        }
        else if (eventType == XmlPullParser.END_TAG) {
            if (parser.getName().equals(elementName)) {
                done = true;
            }
        }
    }
    return extension;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;实现需求&lt;/h2&gt;

&lt;p&gt;回到一开始的例子，我们对Message进行了扩展，所以需要定义一个&lt;code&gt;PacketExtension&lt;/code&gt;，作为自定义的&lt;code&gt;params&lt;/code&gt;对应的包扩展。&lt;/p&gt;

&lt;p&gt;MultiTypeMessage是一个抽象类，抽象方法&lt;code&gt;public abstract String toXML();&lt;/code&gt;交给具体的子类去实现。这个类中还提供了一些工具方法，例如，组装&lt;code&gt;&amp;lt;param/&amp;gt;&lt;/code&gt;,组装最终的&lt;code&gt;&amp;lt;params xmlns=&quot;yl:xmpp:params&quot;&lt;/code&gt;，使用反射将参数对注入具体的Message对象中。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;File: MultiTypeMessage.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.irusher.xmpp.smackx;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.Map;

import org.jivesoftware.smack.packet.PacketExtension;

public abstract class MultiTypeMessage implements PacketExtension {

    // params holder that store all sub-element of &amp;lt;params
    // xmlns=&quot;yl:xmpp:params&quot;&amp;gt;
    private Map&amp;lt;String, String&amp;gt; paramHolder;

    // different message type
    private String type;

    // TODO write other shared member variables here, e.g. passid,content etc.
    //
    //

    // method in PacketExtension interface
    public String getElementName() {
        return &quot;params&quot;;
    }

    // method in PacketExtension interface
    public String getNamespace() {
        return &quot;yl:xmpp:params&quot;;
    }

    // method in PacketExtension interface
    // when message is being sent,this method will be invoked
    // to get this extension's XML presentation.
    public abstract String toXML();

    String getSubElementName() {
        return &quot;param&quot;;
    }

    String assembleFinalElment(String subElmentStr) {
        StringBuilder sb = new StringBuilder();

        sb.append(&quot;&amp;lt;&quot;).append(getElementName()).append(&quot; xmlns=\&quot;&quot;)
                .append(getNamespace()).append(&quot;\&quot;&amp;gt;&quot;);
        sb.append(subElmentStr);
        sb.append(&quot;&amp;lt;/&quot;).append(getElementName()).append(&quot;&amp;gt;&quot;);

        return sb.toString();
    }

    String assembleSubElement(String name, String value) {
        StringBuilder sb = new StringBuilder();
        sb.append(&quot;&amp;lt;&quot;).append(getSubElementName()).append(&quot; &quot;);
        sb.append(&quot;name=\&quot;&quot;).append(name).append(&quot;\&quot;&amp;gt;&quot;);
        sb.append(value);
        sb.append(&quot;&amp;lt;/&quot;).append(getSubElementName()).append(&quot;&amp;gt;&quot;);

        return sb.toString();
    }

    // utility method used to set object's value hold by the map
    // by using java reflection
    void parseStringToClassAttribute(Class&amp;lt;?&amp;gt; clazz, Object obj,
            Map&amp;lt;String, String&amp;gt; params) {

        for (String key : params.keySet()) {
            String value = params.get(key);

            String methodName = &quot;set&quot;
                    + (String.valueOf(value.charAt(0)).toUpperCase())
                    + (value.substring(1));

            try {
                Method method = clazz.getMethod(methodName, String.class);
                method.invoke(this, value);

            } catch (NoSuchMethodException e) {
                e.printStackTrace();
            } catch (SecurityException e) {
                e.printStackTrace();
            } catch (IllegalAccessException e) {
                e.printStackTrace();
            } catch (IllegalArgumentException e) {
                e.printStackTrace();
            } catch (InvocationTargetException e) {
                e.printStackTrace();
            }
        }
    }

    public Map&amp;lt;String, String&amp;gt; getParamHolder() {
        return paramHolder;
    }

    public void setParamHolder(Map&amp;lt;String, String&amp;gt; paramHolder) {
        this.paramHolder = paramHolder;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    public enum MessageType {
        TEXT(&quot;0&quot;), IMAGE(&quot;1&quot;), VOICE(&quot;2&quot;), FOOT(&quot;3&quot;), WEIBO(&quot;4&quot;);

        private final String type;

        private MessageType(String type) {
            this.type = type;
        }

        public String getType() {
            return type;
        }

        public static MessageType stringToMessageType(String s) {
            if (s == null)
                return null;

            if (s.equals(&quot;0&quot;)) {
                return TEXT;
            } else if (s.equals(&quot;1&quot;)) {
                return IMAGE;
            } else if (s.equals(&quot;2&quot;)) {
                return VOICE;
            } else if (s.equals(&quot;3&quot;)) {
                return FOOT;
            } else if (s.equals(&quot;4&quot;)) {
                return WEIBO;
            }
            return null;
        }
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当smack解析收到的XML后，遇到元素名是'params',命名空间是'yl:xmpp:params'的子元素后，就会调用这个类的解析方法。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;File: MultiTypeMessageExtensionProvider.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.irusher.xmpp.smackx;

import java.util.HashMap;
import java.util.Map;

import org.jivesoftware.smack.packet.PacketExtension;
import org.jivesoftware.smack.provider.PacketExtensionProvider;
import org.xmlpull.v1.XmlPullParser;

public class MultiTypeMessageExtensionProvider implements
        PacketExtensionProvider {

    public PacketExtension parseExtension(XmlPullParser parser)
            throws Exception {

        Map&amp;lt;String, String&amp;gt; paramHolder = new HashMap&amp;lt;String, String&amp;gt;();

        // parse raw XML stream and put all param pairs into a map
        boolean done = false;
        while (!done) {
            int eventType = parser.next();
            if (eventType == XmlPullParser.START_TAG) {
                if (parser.getName().equals(&quot;param&quot;)) {
                    paramHolder.put(parser.getAttributeValue(0),
                            parser.nextText());
                }
            } else if (eventType == XmlPullParser.END_TAG) {
                if (parser.getName().equals(&quot;params&quot;)) {
                    done = true;
                }
            }
        }

        // invoke MessageFactory to create a message object with different type 
        MultiTypeMessage message = MessageFactory.getInstance().createMessage(
                paramHolder);

        return message;
    }

}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;图片信息类，保持具体的图片信息相关的参数，并负责XML化。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;File: ImageMessage.java&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package com.irusher.xmpp.smackx;

import java.util.Map;

public class ImageMessage extends MultiTypeMessage {

    private String url;
    private String width;
    private String height;

    public ImageMessage() {
        this.setType(MessageType.IMAGE.getType());
    }

    public ImageMessage(Map&amp;lt;String, String&amp;gt; params) {
        this.setParamHolder(params);
        this.setType(MessageType.IMAGE.getType());
        parseStringToClassAttribute(ImageMessage.class, this, params);
    }

    /**
     * &amp;lt;code&amp;gt;&amp;amp;lt;param name=&quot;url&quot;&amp;amp;gt;http://xxx.com/img.png&amp;amp;lt;/param&amp;amp;gt;
     * &amp;amp;lt;param name=&quot;width&quot;&amp;amp;gt;100&amp;amp;gt;
     * &amp;amp;lt;param name=&quot;height&quot;&amp;amp;gt;100&amp;amp;lt;/param&amp;amp;gt;&amp;lt;/code&amp;gt;
     */
    @Override
    public String toXML() {

        StringBuilder sb = new StringBuilder();
        sb.append(assembleSubElement(&quot;url&quot;, this.url));
        sb.append(assembleSubElement(&quot;width&quot;, String.valueOf(this.width)));
        sb.append(assembleSubElement(&quot;height&quot;, String.valueOf(this.height)));
        return assembleFinalElment(sb.toString());
    }

    public String getUrl() {
        return url;
    }

    public void setUrl(String url) {
        this.url = url;
    }

    public String getWidth() {
        return width;
    }

    public void setWidth(String width) {
        this.width = width;
    }

    public String getHeight() {
        return height;
    }

    public void setHeight(String height) {
        this.height = height;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以在程序中注册扩展包提供者；&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;ProviderManager manager = ProviderManager.getInstance();
manager.addExtensionProvider(&quot;params&quot;, &quot;yl:xmpp:params&quot;,
        new MultiTypeMessageExtensionProvider());
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者在smack.providers中声明一个扩展包提供者：&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;File : smack.providers&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;

&amp;lt;smackProviders&amp;gt;
    &amp;lt;extensionProvider&amp;gt;
        &amp;lt;elementName&amp;gt;params&amp;lt;/elementName&amp;gt;
        &amp;lt;namespace&amp;gt;yl:xmpp:params&amp;lt;/namespace&amp;gt;
        &amp;lt;className&amp;gt;com.irusher.xmpp.smackx.MultiTypeMessageExtensionProvider&amp;lt;/className&amp;gt;
    &amp;lt;/extensionProvider&amp;gt;
&amp;lt;/smackProviders&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;相关文档&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://www.igniterealtime.org/builds/smack/docs/latest/javadoc/org/jivesoftware/smack/packet/PacketExtension.html&quot;&gt;Smack JavaDoc&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://www.igniterealtime.org/builds/smack/docs/latest/documentation/providers.html&quot;&gt;Smack: Provider Architecture: Packet Extensions and Custom IQ's&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

</content>
   </entry>
   
   <entry>
     <title>XEP-0050_专用命令</title>
     <link href="http://beiyuu.com/XEP-0050_%E4%B8%93%E7%94%A8%E5%91%BD%E4%BB%A4"/>
     <updated>2013-05-10T00:00:00+08:00</updated>
     <id>http://beiyuu.com/XEP-0050_专用命令</id>
     <content type="html">&lt;blockquote&gt;&lt;p&gt;  &lt;a href=&quot;http://xmpp.org/extensions/xep-0050.html&quot;&gt;XEP-0050: Ad-Hoc Commands&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;

&lt;h2&gt;1.Introduction&lt;/h2&gt;

&lt;p&gt;此扩展协议的可以使两个实体间建立一个命令会话,而不需要特定的命名空间，同时，还定义了会话的类型，类似于菜单的概念。&lt;/p&gt;

&lt;p&gt;定义这样的一个协议的动机是扩展Jabber的技术，使之不仅仅应用在即时通信上。就像Web应用一样，Jabber应用也是需要一个客户端，一个用户可以通过他来和web应用交互。客户端不需要特殊的改写就可以使用Jabber应用。&lt;/p&gt;

&lt;p&gt;分配给此扩展协议的命名空间是&lt;strong&gt;&quot;http://jabber.org/protocol/commands&quot;&lt;/strong&gt;.这个命名空间依赖&lt;code&gt;&amp;lt;iq/&amp;gt;&lt;/code&gt;元素来执行命令，使用&lt;code&gt;&amp;lt;message/&amp;gt;&lt;/code&gt;返回执行结果。协议依赖&lt;a href=&quot;http://xmpp.org/extensions/xep-0030.html&quot;&gt;XEP-0030: Service Discovery&lt;/a&gt;查询服务支持的命令。协议倾向于实现&lt;a href=&quot;http://xmpp.org/extensions/xep-0004.html&quot;&gt;XEP-0004: Data Forms&lt;/a&gt;扩展协议，但这不是必需的。&lt;/p&gt;

&lt;h2&gt;2.Use Cases&lt;/h2&gt;

&lt;h3&gt;2.1 Discovering Support&lt;/h3&gt;

&lt;p&gt;请求者使用*服务查询*来查看服务端是否支持x-commands。请求者生成一个&quot;#info&quot;查询发到服务端。如果支持，服务端返回一个&lt;code&gt;&amp;lt;feature/&amp;gt;&lt;/code&gt;元素，其中&lt;code&gt;var&lt;/code&gt;属性的值为&lt;code&gt;&quot;http://jabber.org/protocol/commands&quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;客户端请求服务端：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;iq type='get'
    to='responder@domain'
    from='requester@domain'&amp;gt;
  &amp;lt;query xmlns='http://jabber.org/protocol/disco#info'/&amp;gt;
&amp;lt;/iq&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;服务端返回客户端：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;iq type='result'
    from='responder@domain'
    to='requester@domain'&amp;gt;
  &amp;lt;query xmlns='http://jabber.org/protocol/disco#info'&amp;gt;
    ...
    &amp;lt;feature var='http://jabber.org/protocol/commands'/&amp;gt;
    ...
  &amp;lt;/query&amp;gt;
&amp;lt;/iq&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2.2 获取命令列表&lt;/h3&gt;

&lt;p&gt;…一些信息查询 …&lt;/p&gt;

&lt;h3&gt;2.4 命令执行过程&lt;/h3&gt;

&lt;h3&gt;2.4.1 单步执行&lt;/h3&gt;

&lt;p&gt;请求这发一个包含命令的&lt;code&gt;&amp;lt;iq/&amp;gt;&lt;/code&gt;来执行命令.&lt;/p&gt;

&lt;p&gt;执行命令&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;iq type='set' to='responder@domain' id='exec1'&amp;gt;
  &amp;lt;command xmlns='http://jabber.org/protocol/commands'
           node='list'
           action='execute'/&amp;gt;
&amp;lt;/iq&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;请求命令可能包含&lt;code&gt;action='execute'&lt;/code&gt;，这是默认值。&lt;/p&gt;

&lt;p&gt;如果命令不包含其他的交互步骤，服务端发送一个类似下面的数据：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;iq type='result' from='responder@domain' to='requester@domain' id='exec1'&amp;gt;
  &amp;lt;command xmlns='http://jabber.org/protocol/commands'
           sessionid='list:20020923T213616Z-700'
           node='list'
           status='completed'&amp;gt;
    &amp;lt;x xmlns='jabber:x:data' type='result'&amp;gt;
      &amp;lt;title&amp;gt;Available Services&amp;lt;/title&amp;gt;
      &amp;lt;reported&amp;gt;
        &amp;lt;field var='service' label='Service'/&amp;gt;
        &amp;lt;field var='runlevel-1' label='Single-User mode'/&amp;gt;
        &amp;lt;field var='runlevel-2' label='Non-Networked Multi-User mode'/&amp;gt;
        &amp;lt;field var='runlevel-3' label='Full Multi-User mode'/&amp;gt;
        &amp;lt;field var='runlevel-5' label='X-Window mode'/&amp;gt;
      &amp;lt;/reported&amp;gt;
      &amp;lt;item&amp;gt;
        &amp;lt;field var='service'&amp;gt;&amp;lt;value&amp;gt;httpd&amp;lt;/value&amp;gt;&amp;lt;/field&amp;gt;
        &amp;lt;field var='runlevel-1'&amp;gt;&amp;lt;value&amp;gt;off&amp;lt;/value&amp;gt;&amp;lt;/field&amp;gt;
        &amp;lt;field var='runlevel-2'&amp;gt;&amp;lt;value&amp;gt;off&amp;lt;/value&amp;gt;&amp;lt;/field&amp;gt;
        &amp;lt;field var='runlevel-3'&amp;gt;&amp;lt;value&amp;gt;on&amp;lt;/value&amp;gt;&amp;lt;/field&amp;gt;
        &amp;lt;field var='runlevel-5'&amp;gt;&amp;lt;value&amp;gt;on&amp;lt;/value&amp;gt;&amp;lt;/field&amp;gt;
      &amp;lt;/item&amp;gt;
      &amp;lt;item&amp;gt;
        &amp;lt;field var='service'&amp;gt;&amp;lt;value&amp;gt;postgresql&amp;lt;/value&amp;gt;&amp;lt;/field&amp;gt;
        &amp;lt;field var='runlevel-1'&amp;gt;&amp;lt;value&amp;gt;off&amp;lt;/value&amp;gt;&amp;lt;/field&amp;gt;
        &amp;lt;field var='runlevel-2'&amp;gt;&amp;lt;value&amp;gt;off&amp;lt;/value&amp;gt;&amp;lt;/field&amp;gt;
        &amp;lt;field var='runlevel-3'&amp;gt;&amp;lt;value&amp;gt;on&amp;lt;/value&amp;gt;&amp;lt;/field&amp;gt;
        &amp;lt;field var='runlevel-5'&amp;gt;&amp;lt;value&amp;gt;on&amp;lt;/value&amp;gt;&amp;lt;/field&amp;gt;
      &amp;lt;/item&amp;gt;
      &amp;lt;item&amp;gt;
        &amp;lt;field var='service'&amp;gt;&amp;lt;value&amp;gt;jabberd&amp;lt;/value&amp;gt;&amp;lt;/field&amp;gt;
        &amp;lt;field var='runlevel-1'&amp;gt;&amp;lt;value&amp;gt;off&amp;lt;/value&amp;gt;&amp;lt;/field&amp;gt;
        &amp;lt;field var='runlevel-2'&amp;gt;&amp;lt;value&amp;gt;off&amp;lt;/value&amp;gt;&amp;lt;/field&amp;gt;
        &amp;lt;field var='runlevel-3'&amp;gt;&amp;lt;value&amp;gt;on&amp;lt;/value&amp;gt;&amp;lt;/field&amp;gt;
        &amp;lt;field var='runlevel-5'&amp;gt;&amp;lt;value&amp;gt;on&amp;lt;/value&amp;gt;&amp;lt;/field&amp;gt;
      &amp;lt;/item&amp;gt;
    &amp;lt;/x&amp;gt;
  &amp;lt;/command&amp;gt;
&amp;lt;/iq&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的返回数据是&quot;jabber:x:data&quot;规格的表单。&lt;/p&gt;

&lt;h3&gt;2.4.2 多步执行&lt;/h3&gt;

&lt;p&gt;如果命令需要更多的交互步骤，服务端返回关于命令的信息的&lt;code&gt;&amp;lt;iq/&amp;gt;&lt;/code&gt;结果。&lt;/p&gt;

&lt;p&gt;执行命令请求(stage1)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;iq type='set' to='responder@domain' id='exec1'&amp;gt;
  &amp;lt;command xmlns='http://jabber.org/protocol/commands'
           node='config'
           action='execute'/&amp;gt;
&amp;lt;/iq&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回执行结果(stage1)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;iq type='result' from='responder@domain' to='requester@domain' id='exec1'&amp;gt;
  &amp;lt;command xmlns='http://jabber.org/protocol/commands'
           sessionid='config:20020923T213616Z-700'
           node='config'
           status='executing'&amp;gt;
    &amp;lt;actions execute='next'&amp;gt;
      &amp;lt;next/&amp;gt;
    &amp;lt;/actions&amp;gt;
    &amp;lt;x xmlns='jabber:x:data' type='form'&amp;gt;
      &amp;lt;title&amp;gt;Configure Service&amp;lt;/title&amp;gt;
      &amp;lt;instructions&amp;gt;
        Please select the service to configure.
      &amp;lt;/instructions&amp;gt;
      &amp;lt;field var='service' label='Service' type='list-single'&amp;gt;
        &amp;lt;option&amp;gt;&amp;lt;value&amp;gt;httpd&amp;lt;/value&amp;gt;&amp;lt;/option&amp;gt;
        &amp;lt;option&amp;gt;&amp;lt;value&amp;gt;jabberd&amp;lt;/value&amp;gt;&amp;lt;/option&amp;gt;
        &amp;lt;option&amp;gt;&amp;lt;value&amp;gt;postgresql&amp;lt;/value&amp;gt;&amp;lt;/option&amp;gt;
      &amp;lt;/field&amp;gt;
    &amp;lt;/x&amp;gt;
  &amp;lt;/command&amp;gt;
&amp;lt;/iq&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;command/&amp;gt;&lt;/code&gt;应该包含&lt;code&gt;&amp;lt;actions/&amp;gt;&lt;/code&gt;，用来规定下一步中允许执行哪一种类型的动作。&lt;code&gt;&amp;lt;actions/&amp;gt;&lt;/code&gt;元素中的每个值和&lt;code&gt;&amp;lt;command/&amp;gt;&lt;/code&gt;元素中的action属性相同.execute属性值表示下一步中的默认执行动作的类型。在上面的例子中，下一步的执行类型是'next'。&lt;/p&gt;

&lt;p&gt;请求者继续提交表单，附带命令节点(command node)和sessionid&lt;/p&gt;

&lt;p&gt;执行命令请求(stage2)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;iq type='set' to='responder@domain' id='exec2'&amp;gt;
  &amp;lt;command xmlns='http://jabber.org/protocol/commands'
           sessionid='config:20020923T213616Z-700'
           node='config'&amp;gt;
    &amp;lt;x xmlns='jabber:x:data' type='submit'&amp;gt;
      &amp;lt;field var='service'&amp;gt;
        &amp;lt;value&amp;gt;httpd&amp;lt;/value&amp;gt;
      &amp;lt;/field&amp;gt;
    &amp;lt;/x&amp;gt;
  &amp;lt;/command&amp;gt;
&amp;lt;/iq&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回执行结果(stage2)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;iq type='result' from='responder@domain' to='requester@domain' id='exec2'&amp;gt;
  &amp;lt;command xmlns='http://jabber.org/protocol/commands'
           sessionid='config:20020923T213616Z-700'
           node='config'
           status='executing'&amp;gt;
    &amp;lt;actions execute='complete'&amp;gt;
      &amp;lt;prev/&amp;gt;
      &amp;lt;complete/&amp;gt;
    &amp;lt;/actions&amp;gt;
    &amp;lt;x xmlns='jabber:x:data' type='form'&amp;gt;
      &amp;lt;title&amp;gt;Configure Service&amp;lt;/title&amp;gt;
      &amp;lt;instructions&amp;gt;
        Please select the run modes and state for 'httpd'.
      &amp;lt;/instructions&amp;gt;
      &amp;lt;field var='runlevel' label='Run Modes' type='list-multi'&amp;gt;
        &amp;lt;value&amp;gt;3&amp;lt;/value&amp;gt;
        &amp;lt;value&amp;gt;5&amp;lt;/value&amp;gt;
        &amp;lt;option label='Single-User'&amp;gt;&amp;lt;value&amp;gt;1&amp;lt;/value&amp;gt;&amp;lt;/option&amp;gt;
        &amp;lt;option label='Non-Networked Multi-User'&amp;gt;&amp;lt;value&amp;gt;2&amp;lt;/value&amp;gt;&amp;lt;/option&amp;gt;
        &amp;lt;option label='Full Multi-User'&amp;gt;&amp;lt;value&amp;gt;3&amp;lt;/value&amp;gt;&amp;lt;/option&amp;gt;
        &amp;lt;option label='X-Window'&amp;gt;&amp;lt;value&amp;gt;5&amp;lt;/value&amp;gt;&amp;lt;/option&amp;gt;
      &amp;lt;/field&amp;gt;
      &amp;lt;field var='state' label='Run State' type='list-single'&amp;gt;
        &amp;lt;value&amp;gt;off&amp;lt;/value&amp;gt;
        &amp;lt;option label='Active'&amp;gt;&amp;lt;value&amp;gt;off&amp;lt;/value&amp;gt;&amp;lt;/option&amp;gt;
        &amp;lt;option label='Inactive'&amp;gt;&amp;lt;value&amp;gt;on&amp;lt;/value&amp;gt;&amp;lt;/option&amp;gt;
      &amp;lt;/field&amp;gt;
    &amp;lt;/x&amp;gt;
  &amp;lt;/command&amp;gt;
&amp;lt;/iq&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;执行命令请求(stage3)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;iq type='set' to='responder@domain' id='exec3'&amp;gt;
  &amp;lt;command xmlns='http://jabber.org/protocol/commands'
           sessionid='config:20020923T213616Z-700'
           node='config'&amp;gt;
    &amp;lt;x xmlns='jabber:x:data' type='submit'&amp;gt;
      &amp;lt;field var='mode'&amp;gt;
        &amp;lt;value&amp;gt;3&amp;lt;/value&amp;gt;
      &amp;lt;/field&amp;gt;
      &amp;lt;field var='state'&amp;gt;
        &amp;lt;value&amp;gt;on&amp;lt;/value&amp;gt;
      &amp;lt;/field&amp;gt;
    &amp;lt;/x&amp;gt;
  &amp;lt;/command&amp;gt;
&amp;lt;/iq&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回执行结果(stage3)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;iq type='result' from='responder@domain' to='requester@domain' id='exec3'&amp;gt;
  &amp;lt;command xmlns='http://jabber.org/protocol/commands'
           sessionid='config:20020923T213616Z-700'
           node='config'
           status='completed'&amp;gt;
    &amp;lt;note type='info'&amp;gt;Service 'httpd' has been configured.&amp;lt;/note&amp;gt;
  &amp;lt;/command&amp;gt;
&amp;lt;/iq&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*我的解释: 由于stage2中返回的&lt;code&gt;&amp;lt;actions/&amp;gt;&lt;/code&gt;有两种,'prev'和'complete'，上面的这一步演示了'complete'的执行，下面的例子演示'prev‘执行。*&lt;/p&gt;

&lt;p&gt;如果请求者需要返回上一步，需要发送一个带&quot;action='prev'&quot;的命令iq.&lt;/p&gt;

&lt;p&gt;执行命令请求(stage2 -&gt; stage1)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;iq type='set' to='responder@domain' id='exec2'&amp;gt;
  &amp;lt;command xmlns='http://jabber.org/protocol/commands'
           sessionid='config:20020923T213616Z-700'
           node='config'
           action='prev'/&amp;gt;
&amp;lt;/iq&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回执行结果(stage2 -&gt; stage1)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;iq type='result' from='responder@domain' to='requester@domain' id='exec2'&amp;gt;
  &amp;lt;command xmlns='http://jabber.org/protocol/commands'
           sessionid='config:20020923T213616Z-700'
           node='config'
           status='executing'&amp;gt;
    &amp;lt;actions execute='next'&amp;gt;
      &amp;lt;next/&amp;gt;
    &amp;lt;/actions&amp;gt;
    &amp;lt;x xmlns='jabber:x:data' type='form'&amp;gt;
      &amp;lt;title&amp;gt;Configure Service&amp;lt;/title&amp;gt;
      &amp;lt;instructions&amp;gt;
        Please select the service to configure.
      &amp;lt;/instructions&amp;gt;
      &amp;lt;field var='service' label='Service' type='list-single'&amp;gt;
        &amp;lt;value&amp;gt;httpd&amp;lt;/value&amp;gt;
        &amp;lt;option&amp;gt;&amp;lt;value&amp;gt;httpd&amp;lt;/value&amp;gt;&amp;lt;/option&amp;gt;
        &amp;lt;option&amp;gt;&amp;lt;value&amp;gt;jabberd&amp;lt;/value&amp;gt;&amp;lt;/option&amp;gt;
        &amp;lt;option&amp;gt;&amp;lt;value&amp;gt;postgresql&amp;lt;/value&amp;gt;&amp;lt;/option&amp;gt;
      &amp;lt;/field&amp;gt;
    &amp;lt;/x&amp;gt;
  &amp;lt;/command&amp;gt;
&amp;lt;/iq&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3&gt;2.4.3 取消执行&lt;/h3&gt;

&lt;p&gt;当一个命令有多步执行时，请求者可能会在某一步取消请求。请求者可以发送一个带&quot;action='cancel'&quot;的&lt;code&gt;&amp;lt;command/&amp;gt;&lt;/code&gt;来取消执行命令。&lt;/p&gt;

&lt;p&gt;执行命令请求(stage2取消)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;iq type='set' to='responder@domain' id='exec3'&amp;gt;
  &amp;lt;command xmlns='http://jabber.org/protocol/commands'
           sessionid='config:20020923T213616Z-700'
           node='config'
           action='cancel'/&amp;gt;
&amp;lt;/iq&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;返回执行结果(stage2取消)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;iq type='result' from='responder@domain' to='requester@domain' id='exec3'&amp;gt;
  &amp;lt;command xmlns='http://jabber.org/protocol/commands'
           sessionid='config:20020923T213616Z-700'
           node='config'
           status='canceled'/&amp;gt;
&amp;lt;/iq&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2&gt;3.Implementation Notes&lt;/h2&gt;

&lt;h3&gt;3.1&lt;/h3&gt;

&lt;p&gt;上面的例子只是为了描述协议使用。没有预设的或必需的命令。&lt;/p&gt;

&lt;h3&gt;3.2 命令节点&lt;/h3&gt;

&lt;p&gt;每个命令由它的'node'来标示。这和*服务查询*中返回的&lt;code&gt;&amp;lt;item/&amp;gt;&lt;/code&gt;中的'node'相同。*服务查询*规定每个JID下的所有'node'都应该有唯一的表示。服务端的实现者来保证'node'的唯一性。&lt;/p&gt;

&lt;h3&gt;3.3 会话的生命周期&lt;/h3&gt;

&lt;p&gt;命令的执行是建立在会话之上的。没个会话由'sessionid'属性来标识，在请求者/响应者之间保持合法就可以了。响应者通过请求者带来的信息决定回话的生命周期。&lt;/p&gt;

&lt;p&gt;请求者通过发送一个带'node'属性的&lt;code&gt;&amp;lt;command/&amp;gt;&lt;/code&gt;开始一个新的会话（可以添加一个可选的&quot;status='execute&quot;）。请求者一旦收到'sessionid',就必需开始维持回话的生命周期。服务端通过发送一个&lt;code&gt;&amp;lt;command status='completed'/&amp;gt;&lt;/code&gt;来结束一个会话，或者由请求者发送&lt;code&gt;&amp;lt;command action='cancel'/&amp;gt;&lt;/code&gt;取消sessionid对应的会话。&lt;/p&gt;

&lt;p&gt;会话结束后，sessionid不应该再被重用。响应者(服务端)保证sessionid合法且唯一。&lt;/p&gt;

&lt;p&gt;请求者可能在多个会话中执行相同的命令，如果响应者不允许这样，必需返回&lt;code&gt;&amp;lt;not-allowed/&amp;gt;&lt;/code&gt;错误。&lt;/p&gt;

&lt;h3&gt;3.4 命令执行动作&lt;/h3&gt;

&lt;p&gt;命令执行的每一步中的结果，应该包含一个&lt;code&gt;&amp;lt;actions/&amp;gt;&lt;/code&gt;元素。客户端可以使用这些信息为用户提供一个友好的提示界面。&lt;/p&gt;

&lt;p&gt;对应一个客户端，下面是一些典型的action类型:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;'cancel'动作是一直被允许的；&lt;/li&gt;
&lt;li&gt;如果没有&lt;code&gt;&amp;lt;actions/&amp;gt;&lt;/code&gt;元素，客户端可以使用一个单步执行的对话视图：

&lt;ul&gt;
&lt;li&gt;'execute'动作就等同于'complete'动作。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;如果有&lt;code&gt;&amp;lt;actions/&amp;gt;&lt;/code&gt;元素，客户端应该用一个多步执行的对话视图：

&lt;ul&gt;
&lt;li&gt;'execute'总是被允许的，等同与'next'&lt;/li&gt;
&lt;li&gt;'prev'为返回动作，通常对应于向导界面的返回按钮，如果没有，则不能返回；&lt;/li&gt;
&lt;li&gt;'next'为继续执行动作，通常对应于向导界面的下一步按钮，如果没有，则不能执行下一步；&lt;/li&gt;
&lt;li&gt;'complete'为完成动作，通常对应于向导界面的完成按钮，如果没有，则不能完成；&lt;/li&gt;
&lt;li&gt;如果&lt;code&gt;&amp;lt;actions/&amp;gt;&lt;/code&gt;包含'execute'属性，执行的默认值就是'execute'的值，如果没有，则执行动作没有默认值。&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;特定约定：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;'execute'的属性值不应该是允许执行动作值之外的其他值。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;


&lt;h3&gt;3.5 命令返回&lt;/h3&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;command/&amp;gt;&lt;/code&gt;本身的用处很小，主要用途依赖它所返回的信息。它可以承载有任何'namespace'的元素，不管已有的(如&quot;jabber:x:data&quot;)或是自定义的。唯一的限制是元素不需要特定的父元素，但是需要使用&quot;http://jabber.org/protocol/commands&quot;作为namespace的&lt;code&gt;&amp;lt;command/&amp;gt;&lt;/code&gt;为父元素。&lt;/p&gt;

&lt;p&gt;一般来说，返回信息只能由服务端提供。目前主要的用法使返回&quot;jabber:x:data&quot;。这种情况下，如果服务端返回了一个需要提交的表单，请求应该按表单提交数据。&lt;/p&gt;

&lt;p&gt;如果返回元素的顺序比较重要(当&quot;jabber:x:data&quot;和&quot;jabber:x:oob&quot;标识的元素被返回时)，请求者应当正确处理顺序。早接收到的元素比晚接收到的元素有高的优先级。由同一'namespace'标识的元素具有相同的优先级。&lt;/p&gt;

&lt;h4&gt;3.5.1 使用表单数据&lt;/h4&gt;

&lt;p&gt;当返回是&quot;jabber:x:data&quot;元素，有几种情况可以应用。提交者不应该使用&quot;jabber:x:data&quot;，而应该用&quot;submit&quot;。服务端应该认为任何&lt;code&gt;&amp;lt;x type='cancel'/&amp;gt;&lt;/code&gt;为&lt;code&gt;&amp;lt;x type='submit'/&amp;gt;&lt;/code&gt;。&lt;/p&gt;

&lt;h3&gt;3.6 命令执行成功/失败&lt;/h3&gt;

&lt;p&gt;命令的执行状态只能是'executing','completed'或'cancled'。如果完成了，'status'属性不设置成功或者失败的标识。如果命令完成了但是失败了，服务端必需至少包含一个&lt;code&gt;&amp;lt;note type='error'/&amp;gt;&lt;/code&gt;在它返回的&lt;code&gt;&amp;lt;command status='completed'/&amp;gt;&lt;/code&gt;元素.&lt;/p&gt;

&lt;h3&gt;3.7 国际化&lt;/h3&gt;

&lt;p&gt;...此处省略若干字&lt;/p&gt;

&lt;h2&gt;4. Formal Description&lt;/h2&gt;

&lt;p&gt;x-commands的重点元素是&lt;code&gt;&amp;lt;command/&amp;gt;&lt;/code&gt;.它被用来引导整个流程，还被用来返回命令的选项。&lt;/p&gt;

&lt;h3&gt;4.1 &lt;code&gt;&amp;lt;command/&amp;gt;&lt;/code&gt;元素&lt;/h3&gt;

&lt;p&gt;每个&lt;command/&gt;元素包含一下几个属性：一个node,一个'session id'，一个动作类型，一个状态类型，还有一个语言/地区。一个命令可能包含0个或多个&lt;code&gt;&amp;lt;note/&amp;gt;&lt;/code&gt;元素，可能包含有其他namespace的元素作为返回数据的载体。&quot;jabber:x:data&quot;和&quot;jabber:x:oob&quot;标识的元素通常被用作载体。&lt;/p&gt;

&lt;p&gt;'node'元素唯一的确定命令。这个属性使&lt;strong&gt;必需&lt;/strong&gt;被包含的。&lt;/p&gt;

&lt;p&gt;'sessionid'属性帮助命令在多步执行中定位执行过程。这个属性必须在有子步骤时被赋值，服务端应该初始化并且保存这个属性值。这个值不能没有或为空，可以为任意的字符串。这个值同时也需要请求者在请求命令时保存下来。&lt;/p&gt;

&lt;p&gt;‘status'属性描述了当前命令的执行状态。这个值应该由服务端来设置。如果请求端设置了，服务端必需忽略之。属性值必需是下面的值中的某一个：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;&lt;strong&gt;Status&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;executing&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;The command is being executed.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;completed&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;The command has completed. The command session has ended.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;canceled&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;The command has been canceled. The command session has ended.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;'action'属性规定了这个命令的*下一个命令*可以执行的动作类型。这个值应该只又服务端来定义。如果请求端设置了，服务端必需忽略之。属性值必需是下面的值中的某一个：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;&lt;strong&gt;Action&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;execute&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;The command should be executed or continue to be executed. This is the default value.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;cancel&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;The command should be canceled.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;prev&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;The command should be digress to the previous stage of execution.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;next&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;The command should progress to the next stage of execution.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;complete&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;The command should be completed (if possible).&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;p&gt;'xml:lang'属性指定了这个命令想要用的的语言/地区。这个属性可能由请求者设置，服务端应该返回当前正在用的语言/地区。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;&amp;lt;command/&amp;gt;&lt;/code&gt;元素的子元素(除了&lt;code&gt;&amp;lt;actions/&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;note/&amp;gt;&lt;/code&gt;)都属于命令的执行内容。这些命令的顺序代表它们的优先级，所以前面的元素具有较高的优先级。&lt;/p&gt;

&lt;h3&gt;4.2 &lt;code&gt;&amp;lt;actions/&amp;gt;&lt;/code&gt;元素&lt;/h3&gt;

&lt;p&gt;某一步可以执行那些动作是由&lt;code&gt;&amp;lt;actions/&amp;gt;&lt;/code&gt;指定的。如果命令没有执行完，这个元素应该由服务端来指定，不应该由请求者指定。它还包含一个'execute'属性，用来指定默认的执行类型。它包含的子元素表示可以被执行的类型。&lt;/p&gt;

&lt;p&gt;'execute'定义了客户端的默认行为，应该由服务端来制定，但是必需是&lt;code&gt;&amp;lt;actions/&amp;gt;&lt;/code&gt;的子元素中的一个。&lt;/p&gt;

&lt;p&gt;子元素必须是下面的值中的一个：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;prev&lt;/li&gt;
&lt;li&gt;next&lt;/li&gt;
&lt;li&gt;complete&lt;/li&gt;
&lt;/ul&gt;


&lt;h3&gt;4.3 &lt;code&gt;&amp;lt;note/&amp;gt;&lt;/code&gt;元素&lt;/h3&gt;

&lt;p&gt;关于命令的当前状态的注释在&lt;code&gt;&amp;lt;note/&amp;gt;&lt;/code&gt;元素里提供。这个元素包含命令在一系列步骤中的信息。这个元素包含一个'type'属性，表明note的类型。&lt;code&gt;&amp;lt;note/&amp;gt;&lt;/code&gt;的内容应该是用户可以读懂的信息。&lt;/p&gt;

&lt;p&gt;'type’属性使可选的，默认为'info‘，属性值必须是下面的值中的某一个：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;&lt;strong&gt;Type&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;info&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;The note is informational only. This is not really an exceptional condition.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;warn&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;The note indicates a warning. Possibly due to illogical (yet valid) data.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;error&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;The note indicates an error. The text should indicate the reason for the error.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;h3&gt;4.4 错误类型&lt;/h3&gt;

&lt;p&gt;为了讨论方便，使用一下的前缀代替命名空间的URI&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;xmpp&lt;/strong&gt; : urn:ietf:params:xml:ns:xmpp-stanzas&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;cmd&lt;/strong&gt; : http://jabber.org/protocol/commands&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;下面使执行过程中可能出现的错误：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;&lt;strong&gt;Error Type&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;&lt;strong&gt;General Condition&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;&lt;strong&gt;Specific Condition&lt;/strong&gt;&lt;/th&gt;
&lt;th style=&quot;text-align:center;&quot;&gt;&lt;strong&gt;Description&lt;/strong&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;modify&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;xmpp:bad-request/&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;cmd:malformed-action/&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;The responding JID does not understand the specified action.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;modify&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;xmpp:bad-request/&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;cmd:bad-action/&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;The responding JID cannot accept the specified action.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;modify&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;xmpp:bad-request/&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;cmd:bad-locale/&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;The responding JID cannot accept the specified language/locale.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;modify&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;xmpp:bad-request/&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;cmd:bad-payload/&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;The responding JID cannot accept the specified payload (e.g. the data form did not provide one or more required fields).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;modify&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;xmpp:bad-request/&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;cmd:bad-sessionid/&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;The responding JID cannot accept the specified sessionid.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;cancel&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;xmpp:not-allowed/&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;cmd:session-expired/&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;The requesting JID specified a sessionid that is no longer active (either because it was completed, canceled, or timed out).&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;cancel&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;xmpp:forbidden/&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;NONE&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;The requesting JID is not allowed to execute the command.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;cancel&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;xmpp:item-not-found/&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;NONE&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;The responding JID cannot find the requested command node.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;cancel&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;xmpp:feature-not-implemented/&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;NONE&lt;/td&gt;
&lt;td style=&quot;text-align:center;&quot;&gt;The responding JID does not support &quot;http://jabber.org/protocol/commands&quot;.&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;


&lt;h3&gt;5… 6… 7…&lt;/h3&gt;

&lt;p&gt;此处省略若干字&lt;/p&gt;

&lt;hr /&gt;

&lt;pre&gt;&lt;code&gt;                                                                   +-----------+
                                              *complete            |           |
                                      +---------------------------&amp;gt;| completed |+------------------+
                          *prev       |                            |           |                   |
                     +-----------+    |                            +-----------+                   |
                     |           v    |                                                            v
xxxxxxxxx            |    +-------------+                                                       xxxxxxx
x+-----+x            +----|             |                                                       x+---+x
x|START|x ---------------&amp;gt;|  executing  |                                                       x|END|x
x+-----+x                 |             |----+                                                  x+---+x
xxxxxxxxx                 +-------------+    |                                                  xxxxxxx
                              |  ^           |                                                     ^
                              |  +-----------+                                                     |
                              |     *next                                                          |
                              |                                    +---------+                     |
                              |                                    |         |                     |
                              +-----------------------------------&amp;gt;| cancled |+--------------------+
                                                  *cancle          |         |
                                                                   +---------+
&lt;/code&gt;&lt;/pre&gt;
</content>
   </entry>
   
 
</feed>
